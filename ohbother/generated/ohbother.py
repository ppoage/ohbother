
# python wrapper for package ohbother within overall package ohbother
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy build -build-tags=GOEXPERIMENT=cgocheck2 -output=/Applications/Code/Code/GIT/ohbother/ohbother/core/_generated -no-make=true -vm=/Applications/Code/Code/GIT/ohbother/.venv/bin/python3.12 .

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _ohbother
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from ohbother import ohbother
# and then refer to everything using ohbother. prefix
# packages imported by this package listed below:




# ---- Types ---

# Python type for slice [][]byte
class Slice_Slice_byte(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_ohbother.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_ohbother.IncRef(self.handle)
		else:
			self.handle = _ohbother.Slice_Slice_byte_CTor()
			_ohbother.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Slice_byte.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_ohbother.DecRef(self.handle)
	def __str__(self):
		s = 'ohbother.Slice_Slice_byte len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'ohbother.Slice_Slice_byte([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _ohbother.Slice_Slice_byte_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _ohbother.Slice_Slice_byte_len(self.handle)
				return Slice_Slice_byte(handle=_ohbother.Slice_Slice_byte_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Slice_byte(handle=_ohbother.Slice_Slice_byte_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_ohbother.Slice_Slice_byte_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Slice_byte.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Slice_byte(handle=_ohbother.Slice_Slice_byte_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_ohbother.Slice_Slice_byte_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []interface{}
class Slice_interface_(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_ohbother.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_ohbother.IncRef(self.handle)
		else:
			self.handle = _ohbother.Slice_interface__CTor()
			_ohbother.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_interface_.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_ohbother.DecRef(self.handle)
	def __str__(self):
		s = 'ohbother.Slice_interface_ len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'ohbother.Slice_interface_([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _ohbother.Slice_interface__len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _ohbother.Slice_interface__len(self.handle)
				return Slice_interface_(handle=_ohbother.Slice_interface__subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return _ohbother.Slice_interface__elem(self.handle, key)
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_ohbother.Slice_interface__set(self.handle, idx, value)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_interface_.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _ohbother.Slice_interface__elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_ohbother.Slice_interface__append(self.handle, value)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for map map[string]uint64
class Map_string_uint64(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_ohbother.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_ohbother.IncRef(self.handle)
		else:
			self.handle = _ohbother.Map_string_uint64_CTor()
			_ohbother.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_uint64.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_ohbother.Map_string_uint64_set(self.handle, k, v)
	def __del__(self):
		_ohbother.DecRef(self.handle)
	def __str__(self):
		s = 'ohbother.Map_string_uint64 len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'ohbother.Map_string_uint64({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _ohbother.Map_string_uint64_len(self.handle)
	def __getitem__(self, key):
		return _ohbother.Map_string_uint64_elem(self.handle, key)
	def __setitem__(self, key, value):
		_ohbother.Map_string_uint64_set(self.handle, key, value)
	def __delitem__(self, key):
		return _ohbother.Map_string_uint64_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_ohbother.Map_string_uint64_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _ohbother.Map_string_uint64_contains(self.handle, key)


#---- Enums from Go (collections of consts with same type) ---


#---- Constants from Go: Python can only ask that you please don't change these! ---


# ---- Global Variables: can only use functions to access ---


# ---- Interfaces ---

# Python type for interface ohbother.Logger
class Logger(go.GoClass):
	"""Define a Logger interface\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_ohbother.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_ohbother.IncRef(self.handle)
		else:
			self.handle = 0
	def Debug(self, format, goRun=False, *args):
		"""Debug(str format, []str args) """
		args = Slice_interface_(args)
		_ohbother.ohbother_Logger_Debug(self.handle, format, args.handle, goRun)
	def Error(self, format, goRun=False, *args):
		"""Error(str format, []str args) """
		args = Slice_interface_(args)
		_ohbother.ohbother_Logger_Error(self.handle, format, args.handle, goRun)
	def Info(self, format, goRun=False, *args):
		"""Info(str format, []str args) """
		args = Slice_interface_(args)
		_ohbother.ohbother_Logger_Info(self.handle, format, args.handle, goRun)
	def Warn(self, format, goRun=False, *args):
		"""Warn(str format, []str args) """
		args = Slice_interface_(args)
		_ohbother.ohbother_Logger_Warn(self.handle, format, args.handle, goRun)


# ---- Structs ---

# Python type for struct ohbother.ContinuousPacketReceiver
class ContinuousPacketReceiver(go.GoClass):
	"""ContinuousPacketReceiver provides a streaming interface to receive packets\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_ohbother.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_ohbother.IncRef(self.handle)
		else:
			self.handle = _ohbother.ohbother_ContinuousPacketReceiver_CTor()
			_ohbother.IncRef(self.handle)
	def __del__(self):
		_ohbother.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'ohbother.ContinuousPacketReceiver{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'ohbother.ContinuousPacketReceiver ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def GetNextPacket(self):
		"""GetNextPacket() []int
		
		GetNextPacket returns the next received packet or nil if receiver is closed
		"""
		return go.Slice_byte(handle=_ohbother.ohbother_ContinuousPacketReceiver_GetNextPacket(self.handle))
	def Close(self, goRun=False):
		"""Close() 
		
		Close shuts down the receiver
		"""
		_ohbother.ohbother_ContinuousPacketReceiver_Close(self.handle, goRun)

# Python type for struct ohbother.MultiStreamSender
class MultiStreamSender(go.GoClass):
	"""MultiStreamSender provides high-performance parallel packet sending\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_ohbother.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_ohbother.IncRef(self.handle)
		else:
			self.handle = _ohbother.ohbother_MultiStreamSender_CTor()
			_ohbother.IncRef(self.handle)
			if  0 < len(args):
				self.Cfg = args[0]
			if "Cfg" in kwargs:
				self.Cfg = kwargs["Cfg"]
			if  1 < len(args):
				self.StreamConfig = args[1]
			if "StreamConfig" in kwargs:
				self.StreamConfig = kwargs["StreamConfig"]
			if  2 < len(args):
				self.RateLimit = args[2]
			if "RateLimit" in kwargs:
				self.RateLimit = kwargs["RateLimit"]
			if  3 < len(args):
				self.Payloads = args[3]
			if "Payloads" in kwargs:
				self.Payloads = kwargs["Payloads"]
	def __del__(self):
		_ohbother.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'ohbother.MultiStreamSender{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'ohbother.MultiStreamSender ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Cfg(self):
		return Config(handle=_ohbother.ohbother_MultiStreamSender_Cfg_Get(self.handle))
	@Cfg.setter
	def Cfg(self, value):
		if isinstance(value, go.GoClass):
			_ohbother.ohbother_MultiStreamSender_Cfg_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def StreamConfig(self):
		return MultiStreamConfig(handle=_ohbother.ohbother_MultiStreamSender_StreamConfig_Get(self.handle))
	@StreamConfig.setter
	def StreamConfig(self, value):
		if isinstance(value, go.GoClass):
			_ohbother.ohbother_MultiStreamSender_StreamConfig_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def RateLimit(self):
		return _ohbother.ohbother_MultiStreamSender_RateLimit_Get(self.handle)
	@RateLimit.setter
	def RateLimit(self, value):
		if isinstance(value, go.GoClass):
			_ohbother.ohbother_MultiStreamSender_RateLimit_Set(self.handle, value.handle)
		else:
			_ohbother.ohbother_MultiStreamSender_RateLimit_Set(self.handle, value)
	@property
	def Payloads(self):
		return Slice_Slice_byte(handle=_ohbother.ohbother_MultiStreamSender_Payloads_Get(self.handle))
	@Payloads.setter
	def Payloads(self, value):
		if isinstance(value, go.GoClass):
			_ohbother.ohbother_MultiStreamSender_Payloads_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def SetStreamConfig(self, packetWorkers, streamCount, channelBuffers, reportInterval, goRun=False):
		"""SetStreamConfig(int packetWorkers, int streamCount, int channelBuffers, int reportInterval) 
		
		SetStreamConfig configures the multi-stream sender parameters
		"""
		_ohbother.ohbother_MultiStreamSender_SetStreamConfig(self.handle, packetWorkers, streamCount, channelBuffers, reportInterval, goRun)
	def SetAdvancedConfig(self, enableCPUPinning, disableOrdering, turnstileBurst, enableMetrics, goRun=False):
		"""SetAdvancedConfig(bool enableCPUPinning, bool disableOrdering, int turnstileBurst, bool enableMetrics) 
		
		SetAdvancedConfig configures the advanced streaming options
		"""
		_ohbother.ohbother_MultiStreamSender_SetAdvancedConfig(self.handle, enableCPUPinning, disableOrdering, turnstileBurst, enableMetrics, goRun)
	def AddPayload(self, payload, goRun=False):
		"""AddPayload([]int payload) 
		
		AddPayload adds a single payload to the sender
		"""
		_ohbother.ohbother_MultiStreamSender_AddPayload(self.handle, payload.handle, goRun)
	def Send(self):
		"""Send() str
		
		Send initiates high-performance parallel packet transmission
		"""
		return _ohbother.ohbother_MultiStreamSender_Send(self.handle)
	def GetMetrics(self):
		"""GetMetrics() object
		
		GetMetrics returns performance metrics for the sender
		"""
		return Map_string_uint64(handle=_ohbother.ohbother_MultiStreamSender_GetMetrics(self.handle))
	def IsComplete(self):
		"""IsComplete() bool
		
		IsComplete returns true when all packets have been sent
		"""
		return _ohbother.ohbother_MultiStreamSender_IsComplete(self.handle)
	def GetNextResult(self):
		"""GetNextResult() object
		
		GetNextResult returns the next result with smart buffering
		"""
		return PacketSendResult(handle=_ohbother.ohbother_MultiStreamSender_GetNextResult(self.handle))
	def Wait(self, goRun=False):
		"""Wait() 
		
		Wait blocks until all packets have been sent
		"""
		_ohbother.ohbother_MultiStreamSender_Wait(self.handle, goRun)
	def GetSentCount(self):
		"""GetSentCount() int
		
		GetSentCount returns the number of packets that were successfully sent
		"""
		return _ohbother.ohbother_MultiStreamSender_GetSentCount(self.handle)
	def GetErrorCount(self):
		"""GetErrorCount() int
		
		GetErrorCount returns the number of packets that encountered errors
		"""
		return _ohbother.ohbother_MultiStreamSender_GetErrorCount(self.handle)
	def GetStreamConfig(self):
		"""GetStreamConfig() object
		
		GetStreamConfig returns the current streaming configuration
		"""
		return MultiStreamConfig(handle=_ohbother.ohbother_MultiStreamSender_GetStreamConfig(self.handle))
	def IsOrderingEnabled(self):
		"""IsOrderingEnabled() bool
		
		IsOrderingEnabled returns whether packet ordering is enabled
		"""
		return _ohbother.ohbother_MultiStreamSender_IsOrderingEnabled(self.handle)
	def IsCPUPinningEnabled(self):
		"""IsCPUPinningEnabled() bool
		
		IsCPUPinningEnabled returns whether CPU pinning is enabled
		"""
		return _ohbother.ohbother_MultiStreamSender_IsCPUPinningEnabled(self.handle)
	def GetTurnstileBurst(self):
		"""GetTurnstileBurst() int
		
		GetTurnstileBurst returns the configured burst size
		"""
		return _ohbother.ohbother_MultiStreamSender_GetTurnstileBurst(self.handle)
	def AreMetricsEnabled(self):
		"""AreMetricsEnabled() bool
		
		AreMetricsEnabled returns whether metrics collection is enabled
		"""
		return _ohbother.ohbother_MultiStreamSender_AreMetricsEnabled(self.handle)
	def FastConvertPayloads(self, payloads):
		"""FastConvertPayloads([][]int payloads) [][]int
		
		FastConvertPayloads converts multiple byte arrays in parallel
		"""
		return Slice_Slice_byte(handle=_ohbother.ohbother_MultiStreamSender_FastConvertPayloads(self.handle, payloads.handle))

# Python type for struct ohbother.PacketReceiver
class PacketReceiver(go.GoClass):
	"""PacketReceiver wraps asynchronous receive operations.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_ohbother.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_ohbother.IncRef(self.handle)
		else:
			self.handle = _ohbother.ohbother_PacketReceiver_CTor()
			_ohbother.IncRef(self.handle)
	def __del__(self):
		_ohbother.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'ohbother.PacketReceiver{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'ohbother.PacketReceiver ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def Result(self):
		"""Result() object
		
		Result blocks until the asynchronous receive operation completes and returns an AsyncResult.
		The returned AsyncResult contains either the slice of packet payloads or an error.
		Otherwise python complains about gopy's returned structure
		"""
		return AsyncResult(handle=_ohbother.ohbother_PacketReceiver_Result(self.handle))
	def ResultNative(self):
		"""ResultNative() [][]int
		
		ResultNative returns a slice of native []byte values by converting each element
		from the raw [][]byte result. This conversion is done in Go so that Python
		will receive a list of bytes objects (via gopy’s built-in conversion), which you
		can directly use as a bytearray.
		"""
		return Slice_Slice_byte(handle=_ohbother.ohbother_PacketReceiver_ResultNative(self.handle))

# Python type for struct ohbother.PcapConfig
class PcapConfig(go.GoClass):
	"""PcapConfig holds additional settings for pcap handles.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_ohbother.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_ohbother.IncRef(self.handle)
		else:
			self.handle = _ohbother.ohbother_PcapConfig_CTor()
			_ohbother.IncRef(self.handle)
			if  0 < len(args):
				self.Iface = args[0]
			if "Iface" in kwargs:
				self.Iface = kwargs["Iface"]
			if  1 < len(args):
				self.SnapLen = args[1]
			if "SnapLen" in kwargs:
				self.SnapLen = kwargs["SnapLen"]
			if  2 < len(args):
				self.Promisc = args[2]
			if "Promisc" in kwargs:
				self.Promisc = kwargs["Promisc"]
			if  3 < len(args):
				self.Timeout = args[3]
			if "Timeout" in kwargs:
				self.Timeout = kwargs["Timeout"]
			if  4 < len(args):
				self.BufferSize = args[4]
			if "BufferSize" in kwargs:
				self.BufferSize = kwargs["BufferSize"]
			if  5 < len(args):
				self.ImmediateMode = args[5]
			if "ImmediateMode" in kwargs:
				self.ImmediateMode = kwargs["ImmediateMode"]
	def __del__(self):
		_ohbother.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'ohbother.PcapConfig{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'ohbother.PcapConfig ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Iface(self):
		return _ohbother.ohbother_PcapConfig_Iface_Get(self.handle)
	@Iface.setter
	def Iface(self, value):
		if isinstance(value, go.GoClass):
			_ohbother.ohbother_PcapConfig_Iface_Set(self.handle, value.handle)
		else:
			_ohbother.ohbother_PcapConfig_Iface_Set(self.handle, value)
	@property
	def SnapLen(self):
		return _ohbother.ohbother_PcapConfig_SnapLen_Get(self.handle)
	@SnapLen.setter
	def SnapLen(self, value):
		if isinstance(value, go.GoClass):
			_ohbother.ohbother_PcapConfig_SnapLen_Set(self.handle, value.handle)
		else:
			_ohbother.ohbother_PcapConfig_SnapLen_Set(self.handle, value)
	@property
	def Promisc(self):
		return _ohbother.ohbother_PcapConfig_Promisc_Get(self.handle)
	@Promisc.setter
	def Promisc(self, value):
		if isinstance(value, go.GoClass):
			_ohbother.ohbother_PcapConfig_Promisc_Set(self.handle, value.handle)
		else:
			_ohbother.ohbother_PcapConfig_Promisc_Set(self.handle, value)
	@property
	def Timeout(self):
		return _ohbother.ohbother_PcapConfig_Timeout_Get(self.handle)
	@Timeout.setter
	def Timeout(self, value):
		if isinstance(value, go.GoClass):
			_ohbother.ohbother_PcapConfig_Timeout_Set(self.handle, value.handle)
		else:
			_ohbother.ohbother_PcapConfig_Timeout_Set(self.handle, value)
	@property
	def BufferSize(self):
		return _ohbother.ohbother_PcapConfig_BufferSize_Get(self.handle)
	@BufferSize.setter
	def BufferSize(self, value):
		if isinstance(value, go.GoClass):
			_ohbother.ohbother_PcapConfig_BufferSize_Set(self.handle, value.handle)
		else:
			_ohbother.ohbother_PcapConfig_BufferSize_Set(self.handle, value)
	@property
	def ImmediateMode(self):
		return _ohbother.ohbother_PcapConfig_ImmediateMode_Get(self.handle)
	@ImmediateMode.setter
	def ImmediateMode(self, value):
		if isinstance(value, go.GoClass):
			_ohbother.ohbother_PcapConfig_ImmediateMode_Set(self.handle, value.handle)
		else:
			_ohbother.ohbother_PcapConfig_ImmediateMode_Set(self.handle, value)

# Python type for struct ohbother.DebugOptions
class DebugOptions(go.GoClass):
	"""Define a debug options struct\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_ohbother.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_ohbother.IncRef(self.handle)
		else:
			self.handle = _ohbother.ohbother_DebugOptions_CTor()
			_ohbother.IncRef(self.handle)
			if  0 < len(args):
				self.Enabled = args[0]
			if "Enabled" in kwargs:
				self.Enabled = kwargs["Enabled"]
			if  1 < len(args):
				self.Level = args[1]
			if "Level" in kwargs:
				self.Level = kwargs["Level"]
			if  2 < len(args):
				self.Logger = args[2]
			if "Logger" in kwargs:
				self.Logger = kwargs["Logger"]
	def __del__(self):
		_ohbother.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'ohbother.DebugOptions{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'ohbother.DebugOptions ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Enabled(self):
		return _ohbother.ohbother_DebugOptions_Enabled_Get(self.handle)
	@Enabled.setter
	def Enabled(self, value):
		if isinstance(value, go.GoClass):
			_ohbother.ohbother_DebugOptions_Enabled_Set(self.handle, value.handle)
		else:
			_ohbother.ohbother_DebugOptions_Enabled_Set(self.handle, value)
	@property
	def Level(self):
		return _ohbother.ohbother_DebugOptions_Level_Get(self.handle)
	@Level.setter
	def Level(self, value):
		if isinstance(value, go.GoClass):
			_ohbother.ohbother_DebugOptions_Level_Set(self.handle, value.handle)
		else:
			_ohbother.ohbother_DebugOptions_Level_Set(self.handle, value)
	@property
	def Logger(self):
		return Logger(handle=_ohbother.ohbother_DebugOptions_Logger_Get(self.handle))
	@Logger.setter
	def Logger(self, value):
		if isinstance(value, go.GoClass):
			_ohbother.ohbother_DebugOptions_Logger_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct ohbother.DefaultLogger
class DefaultLogger(go.GoClass):
	"""Implement a default logger that has a reference to its parent Config\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_ohbother.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_ohbother.IncRef(self.handle)
		else:
			self.handle = _ohbother.ohbother_DefaultLogger_CTor()
			_ohbother.IncRef(self.handle)
	def __del__(self):
		_ohbother.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'ohbother.DefaultLogger{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'ohbother.DefaultLogger ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def Debug(self, format, goRun=False, *args):
		"""Debug(str format, []str args) """
		args = Slice_interface_(args)
		_ohbother.ohbother_DefaultLogger_Debug(self.handle, format, args.handle, goRun)
	def Info(self, format, goRun=False, *args):
		"""Info(str format, []str args) """
		args = Slice_interface_(args)
		_ohbother.ohbother_DefaultLogger_Info(self.handle, format, args.handle, goRun)
	def Warn(self, format, goRun=False, *args):
		"""Warn(str format, []str args) """
		args = Slice_interface_(args)
		_ohbother.ohbother_DefaultLogger_Warn(self.handle, format, args.handle, goRun)
	def Error(self, format, goRun=False, *args):
		"""Error(str format, []str args) """
		args = Slice_interface_(args)
		_ohbother.ohbother_DefaultLogger_Error(self.handle, format, args.handle, goRun)

# Python type for struct ohbother.MultiStreamConfig
class MultiStreamConfig(go.GoClass):
	"""MultiStreamConfig holds configuration for the multi-stream sender\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_ohbother.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_ohbother.IncRef(self.handle)
		else:
			self.handle = _ohbother.ohbother_MultiStreamConfig_CTor()
			_ohbother.IncRef(self.handle)
			if  0 < len(args):
				self.PacketWorkers = args[0]
			if "PacketWorkers" in kwargs:
				self.PacketWorkers = kwargs["PacketWorkers"]
			if  1 < len(args):
				self.StreamCount = args[1]
			if "StreamCount" in kwargs:
				self.StreamCount = kwargs["StreamCount"]
			if  2 < len(args):
				self.ChannelBuffers = args[2]
			if "ChannelBuffers" in kwargs:
				self.ChannelBuffers = kwargs["ChannelBuffers"]
			if  3 < len(args):
				self.ReportInterval = args[3]
			if "ReportInterval" in kwargs:
				self.ReportInterval = kwargs["ReportInterval"]
			if  4 < len(args):
				self.EnableCPUPinning = args[4]
			if "EnableCPUPinning" in kwargs:
				self.EnableCPUPinning = kwargs["EnableCPUPinning"]
			if  5 < len(args):
				self.DisableOrdering = args[5]
			if "DisableOrdering" in kwargs:
				self.DisableOrdering = kwargs["DisableOrdering"]
			if  6 < len(args):
				self.TurnstileBurst = args[6]
			if "TurnstileBurst" in kwargs:
				self.TurnstileBurst = kwargs["TurnstileBurst"]
			if  7 < len(args):
				self.EnableMetrics = args[7]
			if "EnableMetrics" in kwargs:
				self.EnableMetrics = kwargs["EnableMetrics"]
	def __del__(self):
		_ohbother.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'ohbother.MultiStreamConfig{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'ohbother.MultiStreamConfig ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def PacketWorkers(self):
		return _ohbother.ohbother_MultiStreamConfig_PacketWorkers_Get(self.handle)
	@PacketWorkers.setter
	def PacketWorkers(self, value):
		if isinstance(value, go.GoClass):
			_ohbother.ohbother_MultiStreamConfig_PacketWorkers_Set(self.handle, value.handle)
		else:
			_ohbother.ohbother_MultiStreamConfig_PacketWorkers_Set(self.handle, value)
	@property
	def StreamCount(self):
		return _ohbother.ohbother_MultiStreamConfig_StreamCount_Get(self.handle)
	@StreamCount.setter
	def StreamCount(self, value):
		if isinstance(value, go.GoClass):
			_ohbother.ohbother_MultiStreamConfig_StreamCount_Set(self.handle, value.handle)
		else:
			_ohbother.ohbother_MultiStreamConfig_StreamCount_Set(self.handle, value)
	@property
	def ChannelBuffers(self):
		return _ohbother.ohbother_MultiStreamConfig_ChannelBuffers_Get(self.handle)
	@ChannelBuffers.setter
	def ChannelBuffers(self, value):
		if isinstance(value, go.GoClass):
			_ohbother.ohbother_MultiStreamConfig_ChannelBuffers_Set(self.handle, value.handle)
		else:
			_ohbother.ohbother_MultiStreamConfig_ChannelBuffers_Set(self.handle, value)
	@property
	def ReportInterval(self):
		return _ohbother.ohbother_MultiStreamConfig_ReportInterval_Get(self.handle)
	@ReportInterval.setter
	def ReportInterval(self, value):
		if isinstance(value, go.GoClass):
			_ohbother.ohbother_MultiStreamConfig_ReportInterval_Set(self.handle, value.handle)
		else:
			_ohbother.ohbother_MultiStreamConfig_ReportInterval_Set(self.handle, value)
	@property
	def EnableCPUPinning(self):
		return _ohbother.ohbother_MultiStreamConfig_EnableCPUPinning_Get(self.handle)
	@EnableCPUPinning.setter
	def EnableCPUPinning(self, value):
		if isinstance(value, go.GoClass):
			_ohbother.ohbother_MultiStreamConfig_EnableCPUPinning_Set(self.handle, value.handle)
		else:
			_ohbother.ohbother_MultiStreamConfig_EnableCPUPinning_Set(self.handle, value)
	@property
	def DisableOrdering(self):
		return _ohbother.ohbother_MultiStreamConfig_DisableOrdering_Get(self.handle)
	@DisableOrdering.setter
	def DisableOrdering(self, value):
		if isinstance(value, go.GoClass):
			_ohbother.ohbother_MultiStreamConfig_DisableOrdering_Set(self.handle, value.handle)
		else:
			_ohbother.ohbother_MultiStreamConfig_DisableOrdering_Set(self.handle, value)
	@property
	def TurnstileBurst(self):
		return _ohbother.ohbother_MultiStreamConfig_TurnstileBurst_Get(self.handle)
	@TurnstileBurst.setter
	def TurnstileBurst(self, value):
		if isinstance(value, go.GoClass):
			_ohbother.ohbother_MultiStreamConfig_TurnstileBurst_Set(self.handle, value.handle)
		else:
			_ohbother.ohbother_MultiStreamConfig_TurnstileBurst_Set(self.handle, value)
	@property
	def EnableMetrics(self):
		return _ohbother.ohbother_MultiStreamConfig_EnableMetrics_Get(self.handle)
	@EnableMetrics.setter
	def EnableMetrics(self, value):
		if isinstance(value, go.GoClass):
			_ohbother.ohbother_MultiStreamConfig_EnableMetrics_Set(self.handle, value.handle)
		else:
			_ohbother.ohbother_MultiStreamConfig_EnableMetrics_Set(self.handle, value)

# Python type for struct ohbother.PacketConfig
class PacketConfig(go.GoClass):
	"""PacketConfig holds header information for UDP packets.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_ohbother.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_ohbother.IncRef(self.handle)
		else:
			self.handle = _ohbother.ohbother_PacketConfig_CTor()
			_ohbother.IncRef(self.handle)
			if  0 < len(args):
				self.SrcMAC = args[0]
			if "SrcMAC" in kwargs:
				self.SrcMAC = kwargs["SrcMAC"]
			if  1 < len(args):
				self.DstMAC = args[1]
			if "DstMAC" in kwargs:
				self.DstMAC = kwargs["DstMAC"]
			if  2 < len(args):
				self.SrcIP = args[2]
			if "SrcIP" in kwargs:
				self.SrcIP = kwargs["SrcIP"]
			if  3 < len(args):
				self.DstIP = args[3]
			if "DstIP" in kwargs:
				self.DstIP = kwargs["DstIP"]
			if  4 < len(args):
				self.SrcPort = args[4]
			if "SrcPort" in kwargs:
				self.SrcPort = kwargs["SrcPort"]
			if  5 < len(args):
				self.DstPort = args[5]
			if "DstPort" in kwargs:
				self.DstPort = kwargs["DstPort"]
			if  6 < len(args):
				self.BPF = args[6]
			if "BPF" in kwargs:
				self.BPF = kwargs["BPF"]
	def __del__(self):
		_ohbother.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'ohbother.PacketConfig{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'ohbother.PacketConfig ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def SrcMAC(self):
		return go.net_HardwareAddr(handle=_ohbother.ohbother_PacketConfig_SrcMAC_Get(self.handle))
	@SrcMAC.setter
	def SrcMAC(self, value):
		if isinstance(value, go.GoClass):
			_ohbother.ohbother_PacketConfig_SrcMAC_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def DstMAC(self):
		return go.net_HardwareAddr(handle=_ohbother.ohbother_PacketConfig_DstMAC_Get(self.handle))
	@DstMAC.setter
	def DstMAC(self, value):
		if isinstance(value, go.GoClass):
			_ohbother.ohbother_PacketConfig_DstMAC_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def SrcIP(self):
		return _ohbother.ohbother_PacketConfig_SrcIP_Get(self.handle)
	@SrcIP.setter
	def SrcIP(self, value):
		if isinstance(value, go.GoClass):
			_ohbother.ohbother_PacketConfig_SrcIP_Set(self.handle, value.handle)
		else:
			_ohbother.ohbother_PacketConfig_SrcIP_Set(self.handle, value)
	@property
	def DstIP(self):
		return _ohbother.ohbother_PacketConfig_DstIP_Get(self.handle)
	@DstIP.setter
	def DstIP(self, value):
		if isinstance(value, go.GoClass):
			_ohbother.ohbother_PacketConfig_DstIP_Set(self.handle, value.handle)
		else:
			_ohbother.ohbother_PacketConfig_DstIP_Set(self.handle, value)
	@property
	def SrcPort(self):
		return _ohbother.ohbother_PacketConfig_SrcPort_Get(self.handle)
	@SrcPort.setter
	def SrcPort(self, value):
		if isinstance(value, go.GoClass):
			_ohbother.ohbother_PacketConfig_SrcPort_Set(self.handle, value.handle)
		else:
			_ohbother.ohbother_PacketConfig_SrcPort_Set(self.handle, value)
	@property
	def DstPort(self):
		return _ohbother.ohbother_PacketConfig_DstPort_Get(self.handle)
	@DstPort.setter
	def DstPort(self, value):
		if isinstance(value, go.GoClass):
			_ohbother.ohbother_PacketConfig_DstPort_Set(self.handle, value.handle)
		else:
			_ohbother.ohbother_PacketConfig_DstPort_Set(self.handle, value)
	@property
	def BPF(self):
		return _ohbother.ohbother_PacketConfig_BPF_Get(self.handle)
	@BPF.setter
	def BPF(self, value):
		if isinstance(value, go.GoClass):
			_ohbother.ohbother_PacketConfig_BPF_Set(self.handle, value.handle)
		else:
			_ohbother.ohbother_PacketConfig_BPF_Set(self.handle, value)

# Python type for struct ohbother.PacketSendResult
class PacketSendResult(go.GoClass):
	"""PacketSendResult represents the result of sending a single packet\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_ohbother.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_ohbother.IncRef(self.handle)
		else:
			self.handle = _ohbother.ohbother_PacketSendResult_CTor()
			_ohbother.IncRef(self.handle)
			if  0 < len(args):
				self.Index = args[0]
			if "Index" in kwargs:
				self.Index = kwargs["Index"]
			if  1 < len(args):
				self.TotalCount = args[1]
			if "TotalCount" in kwargs:
				self.TotalCount = kwargs["TotalCount"]
			if  2 < len(args):
				self.Elapsed = args[2]
			if "Elapsed" in kwargs:
				self.Elapsed = kwargs["Elapsed"]
	def __del__(self):
		_ohbother.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'ohbother.PacketSendResult{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'ohbother.PacketSendResult ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Index(self):
		return _ohbother.ohbother_PacketSendResult_Index_Get(self.handle)
	@Index.setter
	def Index(self, value):
		if isinstance(value, go.GoClass):
			_ohbother.ohbother_PacketSendResult_Index_Set(self.handle, value.handle)
		else:
			_ohbother.ohbother_PacketSendResult_Index_Set(self.handle, value)
	@property
	def TotalCount(self):
		return _ohbother.ohbother_PacketSendResult_TotalCount_Get(self.handle)
	@TotalCount.setter
	def TotalCount(self, value):
		if isinstance(value, go.GoClass):
			_ohbother.ohbother_PacketSendResult_TotalCount_Set(self.handle, value.handle)
		else:
			_ohbother.ohbother_PacketSendResult_TotalCount_Set(self.handle, value)
	@property
	def Elapsed(self):
		return _ohbother.ohbother_PacketSendResult_Elapsed_Get(self.handle)
	@Elapsed.setter
	def Elapsed(self, value):
		if isinstance(value, go.GoClass):
			_ohbother.ohbother_PacketSendResult_Elapsed_Set(self.handle, value.handle)
		else:
			_ohbother.ohbother_PacketSendResult_Elapsed_Set(self.handle, value)
	def GetError(self):
		"""GetError() str
		
		GetError returns error as string or empty string
		"""
		return _ohbother.ohbother_PacketSendResult_GetError(self.handle)

# Python type for struct ohbother.PacketSequenceSender
class PacketSequenceSender(go.GoClass):
	"""PacketSequenceSender provides a simple API for packet transmission\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_ohbother.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_ohbother.IncRef(self.handle)
		else:
			self.handle = _ohbother.ohbother_PacketSequenceSender_CTor()
			_ohbother.IncRef(self.handle)
			if  0 < len(args):
				self.Cfg = args[0]
			if "Cfg" in kwargs:
				self.Cfg = kwargs["Cfg"]
			if  1 < len(args):
				self.RateLimit = args[1]
			if "RateLimit" in kwargs:
				self.RateLimit = kwargs["RateLimit"]
			if  2 < len(args):
				self.Payloads = args[2]
			if "Payloads" in kwargs:
				self.Payloads = kwargs["Payloads"]
	def __del__(self):
		_ohbother.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'ohbother.PacketSequenceSender{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'ohbother.PacketSequenceSender ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Cfg(self):
		return Config(handle=_ohbother.ohbother_PacketSequenceSender_Cfg_Get(self.handle))
	@Cfg.setter
	def Cfg(self, value):
		if isinstance(value, go.GoClass):
			_ohbother.ohbother_PacketSequenceSender_Cfg_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def RateLimit(self):
		return _ohbother.ohbother_PacketSequenceSender_RateLimit_Get(self.handle)
	@RateLimit.setter
	def RateLimit(self, value):
		if isinstance(value, go.GoClass):
			_ohbother.ohbother_PacketSequenceSender_RateLimit_Set(self.handle, value.handle)
		else:
			_ohbother.ohbother_PacketSequenceSender_RateLimit_Set(self.handle, value)
	@property
	def Payloads(self):
		return Slice_Slice_byte(handle=_ohbother.ohbother_PacketSequenceSender_Payloads_Get(self.handle))
	@Payloads.setter
	def Payloads(self, value):
		if isinstance(value, go.GoClass):
			_ohbother.ohbother_PacketSequenceSender_Payloads_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def AddPayload(self, payload, goRun=False):
		"""AddPayload([]int payload) 
		
		AddPayload adds a payload to the sender's queue
		"""
		_ohbother.ohbother_PacketSequenceSender_AddPayload(self.handle, payload.handle, goRun)
	def Send(self):
		"""Send() str
		
		Send initiates transmission of all queued payloads
		"""
		return _ohbother.ohbother_PacketSequenceSender_Send(self.handle)
	def GetNextResult(self):
		"""GetNextResult() object
		
		GetNextResult returns the result of the next packet send operation
		Returns nil when all packets have been sent
		"""
		return PacketSendResult(handle=_ohbother.ohbother_PacketSequenceSender_GetNextResult(self.handle))
	def IsComplete(self):
		"""IsComplete() bool
		
		IsComplete returns true when all packets have been sent
		"""
		return _ohbother.ohbother_PacketSequenceSender_IsComplete(self.handle)

# Python type for struct ohbother.AsyncResult
class AsyncResult(go.GoClass):
	"""AsyncResult is a composite type that holds the result of an asynchronous receive operation.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_ohbother.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_ohbother.IncRef(self.handle)
		else:
			self.handle = _ohbother.ohbother_AsyncResult_CTor()
			_ohbother.IncRef(self.handle)
			if  0 < len(args):
				self.Packets = args[0]
			if "Packets" in kwargs:
				self.Packets = kwargs["Packets"]
	def __del__(self):
		_ohbother.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'ohbother.AsyncResult{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'ohbother.AsyncResult ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Packets(self):
		return Slice_Slice_byte(handle=_ohbother.ohbother_AsyncResult_Packets_Get(self.handle))
	@Packets.setter
	def Packets(self, value):
		if isinstance(value, go.GoClass):
			_ohbother.ohbother_AsyncResult_Packets_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def GetPackets(self):
		"""GetPackets() [][]int
		
		GetPackets returns the collected packet payloads.
		"""
		return Slice_Slice_byte(handle=_ohbother.ohbother_AsyncResult_GetPackets(self.handle))
	def GetErr(self):
		"""GetErr() str
		
		GetErr returns the error, if any.
		"""
		return _ohbother.ohbother_AsyncResult_GetErr(self.handle)

# Python type for struct ohbother.BytePacket
class BytePacket(go.GoClass):
	"""BytePacket wraps a []byte and is intended to be exposed to Python.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_ohbother.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_ohbother.IncRef(self.handle)
		else:
			self.handle = _ohbother.ohbother_BytePacket_CTor()
			_ohbother.IncRef(self.handle)
			if  0 < len(args):
				self.Data = args[0]
			if "Data" in kwargs:
				self.Data = kwargs["Data"]
	def __del__(self):
		_ohbother.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'ohbother.BytePacket{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'ohbother.BytePacket ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Data(self):
		return go.Slice_byte(handle=_ohbother.ohbother_BytePacket_Data_Get(self.handle))
	@Data.setter
	def Data(self, value):
		if isinstance(value, go.GoClass):
			_ohbother.ohbother_BytePacket_Data_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def GetData(self):
		"""GetData() []int
		
		GetData returns the underlying []byte. With PR #342 in gopy, this should be
		converted automatically to a native Python bytes object.
		"""
		return go.Slice_byte(handle=_ohbother.ohbother_BytePacket_GetData(self.handle))

# Python type for struct ohbother.Config
class Config(go.GoClass):
	"""Config holds both the packet header settings and the pcap settings.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_ohbother.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_ohbother.IncRef(self.handle)
		else:
			self.handle = _ohbother.ohbother_Config_CTor()
			_ohbother.IncRef(self.handle)
			if  0 < len(args):
				self.Pcap = args[0]
			if "Pcap" in kwargs:
				self.Pcap = kwargs["Pcap"]
			if  1 < len(args):
				self.Packet = args[1]
			if "Packet" in kwargs:
				self.Packet = kwargs["Packet"]
			if  2 < len(args):
				self.Debug = args[2]
			if "Debug" in kwargs:
				self.Debug = kwargs["Debug"]
	def __del__(self):
		_ohbother.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'ohbother.Config{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'ohbother.Config ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Pcap(self):
		return PcapConfig(handle=_ohbother.ohbother_Config_Pcap_Get(self.handle))
	@Pcap.setter
	def Pcap(self, value):
		if isinstance(value, go.GoClass):
			_ohbother.ohbother_Config_Pcap_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Packet(self):
		return PacketConfig(handle=_ohbother.ohbother_Config_Packet_Get(self.handle))
	@Packet.setter
	def Packet(self, value):
		if isinstance(value, go.GoClass):
			_ohbother.ohbother_Config_Packet_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Debug(self):
		return DebugOptions(handle=_ohbother.ohbother_Config_Debug_Get(self.handle))
	@Debug.setter
	def Debug(self, value):
		if isinstance(value, go.GoClass):
			_ohbother.ohbother_Config_Debug_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def EnableDebug(self, level, goRun=False):
		"""EnableDebug(int level) 
		
		Level 0: Off (no debug output)
		Level 1: Errors only
		Level 2: Warnings and errors
		Level 3: Info, warnings, and errors
		Level 4: Verbose (debug, info, warnings, and errors)
		"""
		_ohbother.ohbother_Config_EnableDebug(self.handle, level, goRun)
	def DisableDebug(self, goRun=False):
		"""DisableDebug() """
		_ohbother.ohbother_Config_DisableDebug(self.handle, goRun)
	def SetLogger(self, logger, goRun=False):
		"""SetLogger(object logger) """
		_ohbother.ohbother_Config_SetLogger(self.handle, logger.handle, goRun)


# ---- Slices ---


# ---- Maps ---


# ---- Constructors ---
def NewReceiver(cfg):
	"""NewReceiver(object cfg) object
	
	NewReceiver creates a new continuous packet receiver
	"""
	return ContinuousPacketReceiver(handle=_ohbother.ohbother_NewReceiver(cfg.handle))
def NewMultiStreamSender(cfg, rateLimit):
	"""NewMultiStreamSender(object cfg, int rateLimit) object
	
	NewMultiStreamSender creates a high-performance sender with worker pools
	"""
	return MultiStreamSender(handle=_ohbother.ohbother_NewMultiStreamSender(cfg.handle, rateLimit))
def PacketReceiverByCount(cfg, count, timeout):
	"""PacketReceiverByCount(object cfg, int count, float timeout) object
	
	PacketReceiverByCount starts an asynchronous receive that collects UDP packet payloads (as [][]byte)
	until 'count' packets are received, or until the optional timeout (in seconds) is reached (if timeout > 0).
	"""
	return PacketReceiver(handle=_ohbother.ohbother_PacketReceiverByCount(cfg.handle, count, timeout))
def PacketReceiverByTime(cfg, duration):
	"""PacketReceiverByTime(object cfg, float duration) object
	
	PacketReceiverByTime starts an asynchronous receive that collects UDP packet payloads (as [][]byte)
	for the specified duration (in seconds). It immediately returns an PacketReceiver.
	"""
	return PacketReceiver(handle=_ohbother.ohbother_PacketReceiverByTime(cfg.handle, duration))
def BenchmarkReceiveAsync(cfg, duration):
	"""BenchmarkReceiveAsync(object cfg, float duration) object
	
	BenchmarkReceiveAsync starts an asynchronous receive operation for the specified duration (in seconds)
	and returns an AsyncReceiver pointer. Later, the caller can call Result() on the AsyncReceiver
	to obtain the full slice of received UDP payloads (each a []byte) or an error.
	"""
	return PacketReceiver(handle=_ohbother.ohbother_BenchmarkReceiveAsync(cfg.handle, duration))
def NewDefaultLogger(cfg):
	"""NewDefaultLogger(object cfg) object
	
	NewDefaultLogger creates a logger with a reference to its parent Config
	"""
	return DefaultLogger(handle=_ohbother.ohbother_NewDefaultLogger(cfg.handle))
def NewPacketSequenceSender(cfg, rateLimit):
	"""NewPacketSequenceSender(object cfg, int rateLimit) object
	
	NewPacketSequenceSender creates a sender with specified configuration
	"""
	return PacketSequenceSender(handle=_ohbother.ohbother_NewPacketSequenceSender(cfg.handle, rateLimit))
def NewBytePacket(data):
	"""NewBytePacket([]int data) object
	
	NewBytePacket creates a new BytePacket.
	"""
	return BytePacket(handle=_ohbother.ohbother_NewBytePacket(data.handle))
def NewDefaultConfig(iface, srcMAC, dstMAC, srcIP, dstIP, srcPort, dstPort, bpf, SnapLen, Promisc, BufferSize, ImmediateMode):
	"""NewDefaultConfig(str iface, str srcMAC, str dstMAC, str srcIP, str dstIP, int srcPort, int dstPort, str bpf, int SnapLen, bool Promisc, int BufferSize, bool ImmediateMode) object, str
	
	NewDefaultConfig creates a new Config using the provided parameters.
	The iface is set only once under the PcapConfig.
	"""
	return Config(handle=_ohbother.ohbother_NewDefaultConfig(iface, srcMAC, dstMAC, srcIP, dstIP, srcPort, dstPort, bpf, SnapLen, Promisc, BufferSize, ImmediateMode))


# ---- Functions ---
def DeleteSliceBytes(handle, goRun=False):
	"""DeleteSliceBytes(long handle) 
	
	DeleteSliceBytes removes a byte slice from the registry
	"""
	_ohbother.ohbother_DeleteSliceBytes(handle, goRun)
def LogDebug(format, goRun=False, *args):
	"""LogDebug(str format, []str args) 
	
	Add to config.go
	"""
	args = Slice_interface_(args)
	_ohbother.ohbother_LogDebug(format, args.handle, goRun)
def LogError(format, goRun=False, *args):
	"""LogError(str format, []str args) """
	args = Slice_interface_(args)
	_ohbother.ohbother_LogError(format, args.handle, goRun)
def LogWarn(format, goRun=False, *args):
	"""LogWarn(str format, []str args) """
	args = Slice_interface_(args)
	_ohbother.ohbother_LogWarn(format, args.handle, goRun)
def BenchmarkSend(cfg, packetCount, payloadSize, rateLimit):
	"""BenchmarkSend(object cfg, int packetCount, int payloadSize, int rateLimit) float, str"""
	return _ohbother.ohbother_BenchmarkSend(cfg.handle, packetCount, payloadSize, rateLimit)
def PayloadNative(pyPayload):
	"""PayloadNative(str pyPayload) [][]int
	
	PayloadNative converts various payload formats to [][]byte
	"""
	return Slice_Slice_byte(handle=_ohbother.ohbother_PayloadNative(pyPayload))
def ReceivePacketsByCountSync(cfg, count, timeout):
	"""ReceivePacketsByCountSync(object cfg, int count, float timeout) [][]int, str
	
	ReceivePacketsByCountSync is a synchronous wrapper around CallReceivePacketsByCount.
	It collects UDP packets until 'count' packets are received or the optional timeout (in seconds) is reached.
	"""
	return Slice_Slice_byte(handle=_ohbother.ohbother_ReceivePacketsByCountSync(cfg.handle, count, timeout))
def SendByteArrays(cfg, bytePayloads, rateLimit):
	"""SendByteArrays(object cfg, [][]int bytePayloads, int rateLimit) str
	
	SendByteArrays accepts a direct [][]byte type for Python integration
	"""
	return _ohbother.ohbother_SendByteArrays(cfg.handle, bytePayloads.handle, rateLimit)
def SendPacket(cfg, payload, rateLimit):
	"""SendPacket(object cfg, []int payload, int rateLimit) str
	
	SendPacket transmits a single UDP packet
	"""
	return _ohbother.ohbother_SendPacket(cfg.handle, payload.handle, rateLimit)
def LogInfo(format, goRun=False, *args):
	"""LogInfo(str format, []str args) """
	args = Slice_interface_(args)
	_ohbother.ohbother_LogInfo(format, args.handle, goRun)
def NewSliceByteFromBytes(data):
	"""NewSliceByteFromBytes([]int data) long
	
	NewSliceByteFromBytes creates a new byte slice in Go memory
	"""
	return _ohbother.ohbother_NewSliceByteFromBytes(data.handle)
def ReceivePacketsByTimeSync(cfg, duration):
	"""ReceivePacketsByTimeSync(object cfg, float duration) [][]int, str
	
	ReceivePacketsByTimeSync is a synchronous wrapper around CallReceivePacketsByTime.
	It collects UDP packets for the specified duration and returns the slice of packet payloads ([]byte) and an error.
	"""
	return Slice_Slice_byte(handle=_ohbother.ohbother_ReceivePacketsByTimeSync(cfg.handle, duration))
def SendPackets(cfg, rawPayloads, rateLimit):
	"""SendPackets(object cfg, str rawPayloads, int rateLimit) str
	
	SendPackets transmits multiple packets with optional rate limiting
	"""
	return _ohbother.ohbother_SendPackets(cfg.handle, rawPayloads, rateLimit)
def BatchConvertPythonBytesToSlices(rawBytes, numWorkers):
	"""BatchConvertPythonBytesToSlices([][]int rawBytes, int numWorkers) []long
	
	BatchConvertPythonBytesToSlices converts a list of Python byte arrays to Go handles
	"""
	return go.Slice_int64(handle=_ohbother.ohbother_BatchConvertPythonBytesToSlices(rawBytes.handle, numWorkers))


