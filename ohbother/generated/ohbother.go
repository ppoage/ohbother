/*
cgo stubs for package ohbother.
File is generated by gopy. Do not edit.
gopy build -build-tags=GOEXPERIMENT=cgocheck2 -output=/Applications/Code/Code/GIT/ohbother/ohbother/core/_generated -no-make=true -vm=/Applications/Code/Code/GIT/ohbother/.venv/bin/python3.12 .
*/

package main

/*

#cgo CFLAGS: "-I/Library/Frameworks/Python.framework/Versions/3.12/include/python3.12" -Wno-error -Wno-implicit-function-declaration -Wno-int-conversion
#cgo LDFLAGS: "-L/Library/Frameworks/Python.framework/Versions/3.12/lib" "-lpython3.12" -ldl  -framework CoreFoundation

// #define Py_LIMITED_API // need full API for PyRun*
#include <Python.h>
typedef uint8_t bool;
// static inline is trick for avoiding need for extra .c file
// the following are used for build value -- switch on reflect.Kind
// or the types equivalent
static inline PyObject* gopy_build_bool(uint8_t val) {
	return Py_BuildValue("b", val);
}
static inline PyObject* gopy_build_int64(int64_t val) {
	return Py_BuildValue("k", val);
}
static inline PyObject* gopy_build_uint64(uint64_t val) {
	return Py_BuildValue("K", val);
}
static inline PyObject* gopy_build_float64(double val) {
	return Py_BuildValue("d", val);
}
static inline PyObject* gopy_build_string(const char* val) {
	return Py_BuildValue("s", val);
}
static inline void gopy_decref(PyObject* obj) { // macro
	Py_XDECREF(obj);
}
static inline void gopy_incref(PyObject* obj) { // macro
	Py_XINCREF(obj);
}
static inline int gopy_method_check(PyObject* obj) { // macro
	return PyMethod_Check(obj);
}
static inline void gopy_err_handle() {
	if(PyErr_Occurred() != NULL) {
		PyErr_Print();
	}
}

*/
import "C"
import (
	"errors"
	"fmt"
	"reflect"
	"unsafe"

	"github.com/go-python/gopy/gopyh" // handler

	"net"
	"ohbother"
	"time"
)

// main doesn't do anything in lib / pkg mode, but is essential for exe mode
func main() {

}

// initialization functions -- can be called from python after library is loaded
// GoPyInitRunFile runs a separate python file -- call in GoPyInit if it
// steals the main thread e.g., for GUI event loop, as in GoGi startup.

//export GoPyInit
func GoPyInit() {

}

// type for the handle -- int64 for speed (can switch to string)
type GoHandle int64
type CGoHandle C.longlong

// DecRef decrements the reference count for the specified handle
// and deletes it it goes to zero.
//
//export DecRef
func DecRef(handle CGoHandle) {
	gopyh.DecRef(gopyh.CGoHandle(handle))
}

// IncRef increments the reference count for the specified handle.
//
//export IncRef
func IncRef(handle CGoHandle) {
	gopyh.IncRef(gopyh.CGoHandle(handle))
}

// NumHandles returns the number of handles currently in use.
//
//export NumHandles
func NumHandles() int {
	return gopyh.NumHandles()
}

// boolGoToPy converts a Go bool to python-compatible C.char
func boolGoToPy(b bool) C.char {
	if b {
		return 1
	}
	return 0
}

// boolPyToGo converts a python-compatible C.Char to Go bool
func boolPyToGo(b C.char) bool {
	if b != 0 {
		return true
	}
	return false
}

func complex64GoToPy(c complex64) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex64PyToGo(o *C.PyObject) complex64 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float32(v.real), float32(v.imag))
}

func complex128GoToPy(c complex128) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex128PyToGo(o *C.PyObject) complex128 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float64(v.real), float64(v.imag))
}

// errorGoToPy converts a Go error to python-compatible C.CString
func errorGoToPy(e error) *C.char {
	if e != nil {
		return C.CString(e.Error())
	}
	return C.CString("")
}

// --- generated code for package: ohbother below: ---

// ---- External Types Outside of Targeted Packages ---

// Converters for implicit pointer handles for type: net.HardwareAddr
func ptrFromHandle_net_HardwareAddr(h CGoHandle) *net.HardwareAddr {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "net.HardwareAddr")
	if p == nil {
		return nil
	}
	return p.(*net.HardwareAddr)
}
func deptrFromHandle_net_HardwareAddr(h CGoHandle) net.HardwareAddr {
	p := ptrFromHandle_net_HardwareAddr(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_net_HardwareAddr(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("net.HardwareAddr", p))
}

// --- wrapping slice: net.HardwareAddr ---
//
//export net_HardwareAddr_CTor
func net_HardwareAddr_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_net_HardwareAddr(&net.HardwareAddr{}))
}

//export net_HardwareAddr_len
func net_HardwareAddr_len(handle CGoHandle) int {
	return len(deptrFromHandle_net_HardwareAddr(handle))
}

//export net_HardwareAddr_elem
func net_HardwareAddr_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_net_HardwareAddr(handle)
	return C.char(s[_idx])
}

//export net_HardwareAddr_subslice
func net_HardwareAddr_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_net_HardwareAddr(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_net_HardwareAddr(&ss))
}

//export net_HardwareAddr_set
func net_HardwareAddr_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_net_HardwareAddr(handle)
	s[_idx] = byte(_vl)
}

//export net_HardwareAddr_append
func net_HardwareAddr_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_net_HardwareAddr(handle)
	*s = append(*s, byte(_vl))
}

// ---- Package: go ---

// ---- Types ---

// Converters for implicit pointer handles for type: []bool
func ptrFromHandle_Slice_bool(h CGoHandle) *[]bool {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]bool")
	if p == nil {
		return nil
	}
	return p.(*[]bool)
}
func deptrFromHandle_Slice_bool(h CGoHandle) []bool {
	p := ptrFromHandle_Slice_bool(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_bool(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]bool", p))
}

// --- wrapping slice: []bool ---
//
//export Slice_bool_CTor
func Slice_bool_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_bool(&[]bool{}))
}

//export Slice_bool_len
func Slice_bool_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_bool(handle))
}

//export Slice_bool_elem
func Slice_bool_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_bool(handle)
	return boolGoToPy(s[_idx])
}

//export Slice_bool_subslice
func Slice_bool_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_bool(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_bool(&ss))
}

//export Slice_bool_set
func Slice_bool_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_bool(handle)
	s[_idx] = boolPyToGo(_vl)
}

//export Slice_bool_append
func Slice_bool_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_bool(handle)
	*s = append(*s, boolPyToGo(_vl))
}

// Converters for implicit pointer handles for type: []byte
func ptrFromHandle_Slice_byte(h CGoHandle) *[]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]byte")
	if p == nil {
		return nil
	}
	return p.(*[]byte)
}
func deptrFromHandle_Slice_byte(h CGoHandle) []byte {
	p := ptrFromHandle_Slice_byte(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]byte", p))
}

// --- wrapping slice: []byte ---
//
//export Slice_byte_CTor
func Slice_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_byte(&[]byte{}))
}

//export Slice_byte_len
func Slice_byte_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_byte(handle))
}

//export Slice_byte_elem
func Slice_byte_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_byte(handle)
	return C.char(s[_idx])
}

//export Slice_byte_subslice
func Slice_byte_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_byte(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_byte(&ss))
}

//export Slice_byte_set
func Slice_byte_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_byte(handle)
	s[_idx] = byte(_vl)
}

//export Slice_byte_append
func Slice_byte_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_byte(handle)
	*s = append(*s, byte(_vl))
}

//export Slice_byte_from_bytes
func Slice_byte_from_bytes(o *C.PyObject) CGoHandle {
	size := C.PyBytes_Size(o)
	ptr := unsafe.Pointer(C.PyBytes_AsString(o))
	data := make([]byte, size)
	tmp := unsafe.Slice((*byte)(ptr), size)
	copy(data, tmp)
	return handleFromPtr_Slice_byte(&data)
}

//export Slice_byte_to_bytes
func Slice_byte_to_bytes(handle CGoHandle) *C.PyObject {
	s := deptrFromHandle_Slice_byte(handle)
	ptr := unsafe.Pointer(&s[0])
	size := len(s)
	return C.PyBytes_FromStringAndSize((*C.char)(ptr), C.long(size))
}

// Converters for implicit pointer handles for type: []error
func ptrFromHandle_Slice_error(h CGoHandle) *[]error {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]error")
	if p == nil {
		return nil
	}
	return p.(*[]error)
}
func deptrFromHandle_Slice_error(h CGoHandle) []error {
	p := ptrFromHandle_Slice_error(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_error(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]error", p))
}

// --- wrapping slice: []error ---
//
//export Slice_error_CTor
func Slice_error_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_error(&[]error{}))
}

//export Slice_error_len
func Slice_error_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_error(handle))
}

//export Slice_error_elem
func Slice_error_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_error(handle)
	return errorGoToPy(s[_idx])
}

//export Slice_error_subslice
func Slice_error_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_error(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_error(&ss))
}

//export Slice_error_set
func Slice_error_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_error(handle)
	s[_idx] = errors.New(C.GoString(_vl))
}

//export Slice_error_append
func Slice_error_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_error(handle)
	*s = append(*s, errors.New(C.GoString(_vl)))
}

// Converters for implicit pointer handles for type: []float32
func ptrFromHandle_Slice_float32(h CGoHandle) *[]float32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float32")
	if p == nil {
		return nil
	}
	return p.(*[]float32)
}
func deptrFromHandle_Slice_float32(h CGoHandle) []float32 {
	p := ptrFromHandle_Slice_float32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float32", p))
}

// --- wrapping slice: []float32 ---
//
//export Slice_float32_CTor
func Slice_float32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float32(&[]float32{}))
}

//export Slice_float32_len
func Slice_float32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float32(handle))
}

//export Slice_float32_elem
func Slice_float32_elem(handle CGoHandle, _idx int) C.float {
	s := deptrFromHandle_Slice_float32(handle)
	return C.float(s[_idx])
}

//export Slice_float32_subslice
func Slice_float32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float32(&ss))
}

//export Slice_float32_set
func Slice_float32_set(handle CGoHandle, _idx int, _vl C.float) {
	s := deptrFromHandle_Slice_float32(handle)
	s[_idx] = float32(_vl)
}

//export Slice_float32_append
func Slice_float32_append(handle CGoHandle, _vl C.float) {
	s := ptrFromHandle_Slice_float32(handle)
	*s = append(*s, float32(_vl))
}

// Converters for implicit pointer handles for type: []float64
func ptrFromHandle_Slice_float64(h CGoHandle) *[]float64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float64")
	if p == nil {
		return nil
	}
	return p.(*[]float64)
}
func deptrFromHandle_Slice_float64(h CGoHandle) []float64 {
	p := ptrFromHandle_Slice_float64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float64", p))
}

// --- wrapping slice: []float64 ---
//
//export Slice_float64_CTor
func Slice_float64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float64(&[]float64{}))
}

//export Slice_float64_len
func Slice_float64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float64(handle))
}

//export Slice_float64_elem
func Slice_float64_elem(handle CGoHandle, _idx int) C.double {
	s := deptrFromHandle_Slice_float64(handle)
	return C.double(s[_idx])
}

//export Slice_float64_subslice
func Slice_float64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float64(&ss))
}

//export Slice_float64_set
func Slice_float64_set(handle CGoHandle, _idx int, _vl C.double) {
	s := deptrFromHandle_Slice_float64(handle)
	s[_idx] = float64(_vl)
}

//export Slice_float64_append
func Slice_float64_append(handle CGoHandle, _vl C.double) {
	s := ptrFromHandle_Slice_float64(handle)
	*s = append(*s, float64(_vl))
}

// Converters for implicit pointer handles for type: []int
func ptrFromHandle_Slice_int(h CGoHandle) *[]int {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int")
	if p == nil {
		return nil
	}
	return p.(*[]int)
}
func deptrFromHandle_Slice_int(h CGoHandle) []int {
	p := ptrFromHandle_Slice_int(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int", p))
}

// --- wrapping slice: []int ---
//
//export Slice_int_CTor
func Slice_int_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int(&[]int{}))
}

//export Slice_int_len
func Slice_int_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int(handle))
}

//export Slice_int_elem
func Slice_int_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int(handle)
	return C.longlong(s[_idx])
}

//export Slice_int_subslice
func Slice_int_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int(&ss))
}

//export Slice_int_set
func Slice_int_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int(handle)
	s[_idx] = int(_vl)
}

//export Slice_int_append
func Slice_int_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int(handle)
	*s = append(*s, int(_vl))
}

// Converters for implicit pointer handles for type: []int16
func ptrFromHandle_Slice_int16(h CGoHandle) *[]int16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int16")
	if p == nil {
		return nil
	}
	return p.(*[]int16)
}
func deptrFromHandle_Slice_int16(h CGoHandle) []int16 {
	p := ptrFromHandle_Slice_int16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int16", p))
}

// --- wrapping slice: []int16 ---
//
//export Slice_int16_CTor
func Slice_int16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int16(&[]int16{}))
}

//export Slice_int16_len
func Slice_int16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int16(handle))
}

//export Slice_int16_elem
func Slice_int16_elem(handle CGoHandle, _idx int) C.short {
	s := deptrFromHandle_Slice_int16(handle)
	return C.short(s[_idx])
}

//export Slice_int16_subslice
func Slice_int16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int16(&ss))
}

//export Slice_int16_set
func Slice_int16_set(handle CGoHandle, _idx int, _vl C.short) {
	s := deptrFromHandle_Slice_int16(handle)
	s[_idx] = int16(_vl)
}

//export Slice_int16_append
func Slice_int16_append(handle CGoHandle, _vl C.short) {
	s := ptrFromHandle_Slice_int16(handle)
	*s = append(*s, int16(_vl))
}

// Converters for implicit pointer handles for type: []int32
func ptrFromHandle_Slice_int32(h CGoHandle) *[]int32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int32")
	if p == nil {
		return nil
	}
	return p.(*[]int32)
}
func deptrFromHandle_Slice_int32(h CGoHandle) []int32 {
	p := ptrFromHandle_Slice_int32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int32", p))
}

// --- wrapping slice: []int32 ---
//
//export Slice_int32_CTor
func Slice_int32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int32(&[]int32{}))
}

//export Slice_int32_len
func Slice_int32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int32(handle))
}

//export Slice_int32_elem
func Slice_int32_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_int32(handle)
	return C.long(s[_idx])
}

//export Slice_int32_subslice
func Slice_int32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int32(&ss))
}

//export Slice_int32_set
func Slice_int32_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_int32(handle)
	s[_idx] = int32(_vl)
}

//export Slice_int32_append
func Slice_int32_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_int32(handle)
	*s = append(*s, int32(_vl))
}

// Converters for implicit pointer handles for type: []int64
func ptrFromHandle_Slice_int64(h CGoHandle) *[]int64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int64")
	if p == nil {
		return nil
	}
	return p.(*[]int64)
}
func deptrFromHandle_Slice_int64(h CGoHandle) []int64 {
	p := ptrFromHandle_Slice_int64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int64", p))
}

// --- wrapping slice: []int64 ---
//
//export Slice_int64_CTor
func Slice_int64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int64(&[]int64{}))
}

//export Slice_int64_len
func Slice_int64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int64(handle))
}

//export Slice_int64_elem
func Slice_int64_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int64(handle)
	return C.longlong(s[_idx])
}

//export Slice_int64_subslice
func Slice_int64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int64(&ss))
}

//export Slice_int64_set
func Slice_int64_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int64(handle)
	s[_idx] = int64(_vl)
}

//export Slice_int64_append
func Slice_int64_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int64(handle)
	*s = append(*s, int64(_vl))
}

// Converters for implicit pointer handles for type: []int8
func ptrFromHandle_Slice_int8(h CGoHandle) *[]int8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int8")
	if p == nil {
		return nil
	}
	return p.(*[]int8)
}
func deptrFromHandle_Slice_int8(h CGoHandle) []int8 {
	p := ptrFromHandle_Slice_int8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int8", p))
}

// --- wrapping slice: []int8 ---
//
//export Slice_int8_CTor
func Slice_int8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int8(&[]int8{}))
}

//export Slice_int8_len
func Slice_int8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int8(handle))
}

//export Slice_int8_elem
func Slice_int8_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_int8(handle)
	return C.char(s[_idx])
}

//export Slice_int8_subslice
func Slice_int8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int8(&ss))
}

//export Slice_int8_set
func Slice_int8_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_int8(handle)
	s[_idx] = int8(_vl)
}

//export Slice_int8_append
func Slice_int8_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_int8(handle)
	*s = append(*s, int8(_vl))
}

// Converters for implicit pointer handles for type: []rune
func ptrFromHandle_Slice_rune(h CGoHandle) *[]rune {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]rune")
	if p == nil {
		return nil
	}
	return p.(*[]rune)
}
func deptrFromHandle_Slice_rune(h CGoHandle) []rune {
	p := ptrFromHandle_Slice_rune(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_rune(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]rune", p))
}

// --- wrapping slice: []rune ---
//
//export Slice_rune_CTor
func Slice_rune_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_rune(&[]rune{}))
}

//export Slice_rune_len
func Slice_rune_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_rune(handle))
}

//export Slice_rune_elem
func Slice_rune_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_rune(handle)
	return C.long(s[_idx])
}

//export Slice_rune_subslice
func Slice_rune_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_rune(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_rune(&ss))
}

//export Slice_rune_set
func Slice_rune_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_rune(handle)
	s[_idx] = rune(_vl)
}

//export Slice_rune_append
func Slice_rune_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_rune(handle)
	*s = append(*s, rune(_vl))
}

// Converters for implicit pointer handles for type: []string
func ptrFromHandle_Slice_string(h CGoHandle) *[]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]string")
	if p == nil {
		return nil
	}
	return p.(*[]string)
}
func deptrFromHandle_Slice_string(h CGoHandle) []string {
	p := ptrFromHandle_Slice_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]string", p))
}

// --- wrapping slice: []string ---
//
//export Slice_string_CTor
func Slice_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_string(&[]string{}))
}

//export Slice_string_len
func Slice_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_string(handle))
}

//export Slice_string_elem
func Slice_string_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_string(handle)
	return C.CString(s[_idx])
}

//export Slice_string_subslice
func Slice_string_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_string(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_string(&ss))
}

//export Slice_string_set
func Slice_string_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_string(handle)
	s[_idx] = C.GoString(_vl)
}

//export Slice_string_append
func Slice_string_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_string(handle)
	*s = append(*s, C.GoString(_vl))
}

// Converters for implicit pointer handles for type: []uint
func ptrFromHandle_Slice_uint(h CGoHandle) *[]uint {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint")
	if p == nil {
		return nil
	}
	return p.(*[]uint)
}
func deptrFromHandle_Slice_uint(h CGoHandle) []uint {
	p := ptrFromHandle_Slice_uint(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint", p))
}

// --- wrapping slice: []uint ---
//
//export Slice_uint_CTor
func Slice_uint_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint(&[]uint{}))
}

//export Slice_uint_len
func Slice_uint_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint(handle))
}

//export Slice_uint_elem
func Slice_uint_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint_subslice
func Slice_uint_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint(&ss))
}

//export Slice_uint_set
func Slice_uint_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint(handle)
	s[_idx] = uint(_vl)
}

//export Slice_uint_append
func Slice_uint_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint(handle)
	*s = append(*s, uint(_vl))
}

// Converters for implicit pointer handles for type: []uint16
func ptrFromHandle_Slice_uint16(h CGoHandle) *[]uint16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint16")
	if p == nil {
		return nil
	}
	return p.(*[]uint16)
}
func deptrFromHandle_Slice_uint16(h CGoHandle) []uint16 {
	p := ptrFromHandle_Slice_uint16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint16", p))
}

// --- wrapping slice: []uint16 ---
//
//export Slice_uint16_CTor
func Slice_uint16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint16(&[]uint16{}))
}

//export Slice_uint16_len
func Slice_uint16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint16(handle))
}

//export Slice_uint16_elem
func Slice_uint16_elem(handle CGoHandle, _idx int) C.ushort {
	s := deptrFromHandle_Slice_uint16(handle)
	return C.ushort(s[_idx])
}

//export Slice_uint16_subslice
func Slice_uint16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint16(&ss))
}

//export Slice_uint16_set
func Slice_uint16_set(handle CGoHandle, _idx int, _vl C.ushort) {
	s := deptrFromHandle_Slice_uint16(handle)
	s[_idx] = uint16(_vl)
}

//export Slice_uint16_append
func Slice_uint16_append(handle CGoHandle, _vl C.ushort) {
	s := ptrFromHandle_Slice_uint16(handle)
	*s = append(*s, uint16(_vl))
}

// Converters for implicit pointer handles for type: []uint32
func ptrFromHandle_Slice_uint32(h CGoHandle) *[]uint32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint32")
	if p == nil {
		return nil
	}
	return p.(*[]uint32)
}
func deptrFromHandle_Slice_uint32(h CGoHandle) []uint32 {
	p := ptrFromHandle_Slice_uint32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint32", p))
}

// --- wrapping slice: []uint32 ---
//
//export Slice_uint32_CTor
func Slice_uint32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint32(&[]uint32{}))
}

//export Slice_uint32_len
func Slice_uint32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint32(handle))
}

//export Slice_uint32_elem
func Slice_uint32_elem(handle CGoHandle, _idx int) C.ulong {
	s := deptrFromHandle_Slice_uint32(handle)
	return C.ulong(s[_idx])
}

//export Slice_uint32_subslice
func Slice_uint32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint32(&ss))
}

//export Slice_uint32_set
func Slice_uint32_set(handle CGoHandle, _idx int, _vl C.ulong) {
	s := deptrFromHandle_Slice_uint32(handle)
	s[_idx] = uint32(_vl)
}

//export Slice_uint32_append
func Slice_uint32_append(handle CGoHandle, _vl C.ulong) {
	s := ptrFromHandle_Slice_uint32(handle)
	*s = append(*s, uint32(_vl))
}

// Converters for implicit pointer handles for type: []uint64
func ptrFromHandle_Slice_uint64(h CGoHandle) *[]uint64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint64")
	if p == nil {
		return nil
	}
	return p.(*[]uint64)
}
func deptrFromHandle_Slice_uint64(h CGoHandle) []uint64 {
	p := ptrFromHandle_Slice_uint64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint64", p))
}

// --- wrapping slice: []uint64 ---
//
//export Slice_uint64_CTor
func Slice_uint64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint64(&[]uint64{}))
}

//export Slice_uint64_len
func Slice_uint64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint64(handle))
}

//export Slice_uint64_elem
func Slice_uint64_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint64(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint64_subslice
func Slice_uint64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint64(&ss))
}

//export Slice_uint64_set
func Slice_uint64_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint64(handle)
	s[_idx] = uint64(_vl)
}

//export Slice_uint64_append
func Slice_uint64_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint64(handle)
	*s = append(*s, uint64(_vl))
}

// Converters for implicit pointer handles for type: []uint8
func ptrFromHandle_Slice_uint8(h CGoHandle) *[]uint8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint8")
	if p == nil {
		return nil
	}
	return p.(*[]uint8)
}
func deptrFromHandle_Slice_uint8(h CGoHandle) []uint8 {
	p := ptrFromHandle_Slice_uint8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint8", p))
}

// --- wrapping slice: []uint8 ---
//
//export Slice_uint8_CTor
func Slice_uint8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint8(&[]uint8{}))
}

//export Slice_uint8_len
func Slice_uint8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint8(handle))
}

//export Slice_uint8_elem
func Slice_uint8_elem(handle CGoHandle, _idx int) C.uchar {
	s := deptrFromHandle_Slice_uint8(handle)
	return C.uchar(s[_idx])
}

//export Slice_uint8_subslice
func Slice_uint8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint8(&ss))
}

//export Slice_uint8_set
func Slice_uint8_set(handle CGoHandle, _idx int, _vl C.uchar) {
	s := deptrFromHandle_Slice_uint8(handle)
	s[_idx] = uint8(_vl)
}

//export Slice_uint8_append
func Slice_uint8_append(handle CGoHandle, _vl C.uchar) {
	s := ptrFromHandle_Slice_uint8(handle)
	*s = append(*s, uint8(_vl))
}

// ---- Package: ohbother ---

// ---- Types ---

// Converters for pointer handles for type: *ohbother.AsyncResult
func ptrFromHandle_Ptr_ohbother_AsyncResult(h CGoHandle) *ohbother.AsyncResult {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*ohbother.AsyncResult")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ohbother.AsyncResult{})).(*ohbother.AsyncResult)
}
func handleFromPtr_Ptr_ohbother_AsyncResult(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*ohbother.AsyncResult", p))
}

// Converters for pointer handles for type: *ohbother.BytePacket
func ptrFromHandle_Ptr_ohbother_BytePacket(h CGoHandle) *ohbother.BytePacket {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*ohbother.BytePacket")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ohbother.BytePacket{})).(*ohbother.BytePacket)
}
func handleFromPtr_Ptr_ohbother_BytePacket(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*ohbother.BytePacket", p))
}

// Converters for pointer handles for type: *ohbother.Config
func ptrFromHandle_Ptr_ohbother_Config(h CGoHandle) *ohbother.Config {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*ohbother.Config")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ohbother.Config{})).(*ohbother.Config)
}
func handleFromPtr_Ptr_ohbother_Config(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*ohbother.Config", p))
}

// Converters for pointer handles for type: *ohbother.ContinuousPacketReceiver
func ptrFromHandle_Ptr_ohbother_ContinuousPacketReceiver(h CGoHandle) *ohbother.ContinuousPacketReceiver {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*ohbother.ContinuousPacketReceiver")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ohbother.ContinuousPacketReceiver{})).(*ohbother.ContinuousPacketReceiver)
}
func handleFromPtr_Ptr_ohbother_ContinuousPacketReceiver(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*ohbother.ContinuousPacketReceiver", p))
}

// Converters for pointer handles for type: *ohbother.DebugOptions
func ptrFromHandle_Ptr_ohbother_DebugOptions(h CGoHandle) *ohbother.DebugOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*ohbother.DebugOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ohbother.DebugOptions{})).(*ohbother.DebugOptions)
}
func handleFromPtr_Ptr_ohbother_DebugOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*ohbother.DebugOptions", p))
}

// Converters for pointer handles for type: *ohbother.DefaultLogger
func ptrFromHandle_Ptr_ohbother_DefaultLogger(h CGoHandle) *ohbother.DefaultLogger {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*ohbother.DefaultLogger")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ohbother.DefaultLogger{})).(*ohbother.DefaultLogger)
}
func handleFromPtr_Ptr_ohbother_DefaultLogger(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*ohbother.DefaultLogger", p))
}

// Converters for pointer handles for type: *ohbother.MultiStreamConfig
func ptrFromHandle_Ptr_ohbother_MultiStreamConfig(h CGoHandle) *ohbother.MultiStreamConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*ohbother.MultiStreamConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ohbother.MultiStreamConfig{})).(*ohbother.MultiStreamConfig)
}
func handleFromPtr_Ptr_ohbother_MultiStreamConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*ohbother.MultiStreamConfig", p))
}

// Converters for pointer handles for type: *ohbother.MultiStreamSender
func ptrFromHandle_Ptr_ohbother_MultiStreamSender(h CGoHandle) *ohbother.MultiStreamSender {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*ohbother.MultiStreamSender")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ohbother.MultiStreamSender{})).(*ohbother.MultiStreamSender)
}
func handleFromPtr_Ptr_ohbother_MultiStreamSender(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*ohbother.MultiStreamSender", p))
}

// Converters for pointer handles for type: *ohbother.PacketConfig
func ptrFromHandle_Ptr_ohbother_PacketConfig(h CGoHandle) *ohbother.PacketConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*ohbother.PacketConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ohbother.PacketConfig{})).(*ohbother.PacketConfig)
}
func handleFromPtr_Ptr_ohbother_PacketConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*ohbother.PacketConfig", p))
}

// Converters for pointer handles for type: *ohbother.PacketReceiver
func ptrFromHandle_Ptr_ohbother_PacketReceiver(h CGoHandle) *ohbother.PacketReceiver {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*ohbother.PacketReceiver")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ohbother.PacketReceiver{})).(*ohbother.PacketReceiver)
}
func handleFromPtr_Ptr_ohbother_PacketReceiver(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*ohbother.PacketReceiver", p))
}

// Converters for pointer handles for type: *ohbother.PacketSendResult
func ptrFromHandle_Ptr_ohbother_PacketSendResult(h CGoHandle) *ohbother.PacketSendResult {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*ohbother.PacketSendResult")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ohbother.PacketSendResult{})).(*ohbother.PacketSendResult)
}
func handleFromPtr_Ptr_ohbother_PacketSendResult(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*ohbother.PacketSendResult", p))
}

// Converters for pointer handles for type: *ohbother.PacketSequenceSender
func ptrFromHandle_Ptr_ohbother_PacketSequenceSender(h CGoHandle) *ohbother.PacketSequenceSender {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*ohbother.PacketSequenceSender")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ohbother.PacketSequenceSender{})).(*ohbother.PacketSequenceSender)
}
func handleFromPtr_Ptr_ohbother_PacketSequenceSender(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*ohbother.PacketSequenceSender", p))
}

// Converters for pointer handles for type: *ohbother.PcapConfig
func ptrFromHandle_Ptr_ohbother_PcapConfig(h CGoHandle) *ohbother.PcapConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*ohbother.PcapConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ohbother.PcapConfig{})).(*ohbother.PcapConfig)
}
func handleFromPtr_Ptr_ohbother_PcapConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*ohbother.PcapConfig", p))
}

// Converters for implicit pointer handles for type: [][]byte
func ptrFromHandle_Slice_Slice_byte(h CGoHandle) *[][]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[][]byte")
	if p == nil {
		return nil
	}
	return p.(*[][]byte)
}
func deptrFromHandle_Slice_Slice_byte(h CGoHandle) [][]byte {
	p := ptrFromHandle_Slice_Slice_byte(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Slice_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[][]byte", p))
}

// --- wrapping slice: [][]byte ---
//
//export Slice_Slice_byte_CTor
func Slice_Slice_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Slice_byte(&[][]byte{}))
}

//export Slice_Slice_byte_len
func Slice_Slice_byte_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Slice_byte(handle))
}

//export Slice_Slice_byte_elem
func Slice_Slice_byte_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Slice_byte(handle)
	return handleFromPtr_Slice_byte(&(s[_idx]))
}

//export Slice_Slice_byte_subslice
func Slice_Slice_byte_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Slice_byte(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Slice_byte(&ss))
}

//export Slice_Slice_byte_set
func Slice_Slice_byte_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Slice_byte(handle)
	s[_idx] = deptrFromHandle_Slice_byte(_vl)
}

//export Slice_Slice_byte_append
func Slice_Slice_byte_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Slice_byte(handle)
	*s = append(*s, deptrFromHandle_Slice_byte(_vl))
}

// Converters for implicit pointer handles for type: []interface{}
func ptrFromHandle_Slice_interface_(h CGoHandle) *[]interface{} {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]interface{}")
	if p == nil {
		return nil
	}
	return p.(*[]interface{})
}
func deptrFromHandle_Slice_interface_(h CGoHandle) []interface{} {
	p := ptrFromHandle_Slice_interface_(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_interface_(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]interface{}", p))
}

// --- wrapping slice: []interface{} ---
//
//export Slice_interface__CTor
func Slice_interface__CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_interface_(&[]interface{}{}))
}

//export Slice_interface__len
func Slice_interface__len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_interface_(handle))
}

//export Slice_interface__elem
func Slice_interface__elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_interface_(handle)
	return C.CString(fmt.Sprintf("%s", (s[_idx])))
}

//export Slice_interface__subslice
func Slice_interface__subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_interface_(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_interface_(&ss))
}

//export Slice_interface__set
func Slice_interface__set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_interface_(handle)
	s[_idx] = C.GoString(_vl)
}

//export Slice_interface__append
func Slice_interface__append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_interface_(handle)
	*s = append(*s, C.GoString(_vl))
}

// Converters for implicit pointer handles for type: map[string]uint64
func ptrFromHandle_Map_string_uint64(h CGoHandle) *map[string]uint64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]uint64")
	if p == nil {
		return nil
	}
	return p.(*map[string]uint64)
}
func deptrFromHandle_Map_string_uint64(h CGoHandle) map[string]uint64 {
	p := ptrFromHandle_Map_string_uint64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_uint64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]uint64", p))
}

// --- wrapping map: map[string]uint64 ---
//
//export Map_string_uint64_CTor
func Map_string_uint64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_uint64(&map[string]uint64{}))
}

//export Map_string_uint64_len
func Map_string_uint64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_uint64(handle))
}

//export Map_string_uint64_elem
func Map_string_uint64_elem(handle CGoHandle, _ky *C.char) C.ulonglong {
	s := deptrFromHandle_Map_string_uint64(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return C.ulonglong(v)
}

//export Map_string_uint64_contains
func Map_string_uint64_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_uint64(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_uint64_set
func Map_string_uint64_set(handle CGoHandle, _ky *C.char, _vl C.ulonglong) {
	s := deptrFromHandle_Map_string_uint64(handle)
	s[C.GoString(_ky)] = uint64(_vl)
}

//export Map_string_uint64_delete
func Map_string_uint64_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_uint64(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_uint64_keys
func Map_string_uint64_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_uint64(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for non-pointer handles for type: ohbother.AsyncResult
func ptrFromHandle_ohbother_AsyncResult(h CGoHandle) *ohbother.AsyncResult {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "ohbother.AsyncResult")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ohbother.AsyncResult{})).(*ohbother.AsyncResult)
}
func handleFromPtr_ohbother_AsyncResult(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("ohbother.AsyncResult", p))
}

// Converters for non-pointer handles for type: ohbother.BytePacket
func ptrFromHandle_ohbother_BytePacket(h CGoHandle) *ohbother.BytePacket {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "ohbother.BytePacket")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ohbother.BytePacket{})).(*ohbother.BytePacket)
}
func handleFromPtr_ohbother_BytePacket(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("ohbother.BytePacket", p))
}

// Converters for non-pointer handles for type: ohbother.Config
func ptrFromHandle_ohbother_Config(h CGoHandle) *ohbother.Config {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "ohbother.Config")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ohbother.Config{})).(*ohbother.Config)
}
func handleFromPtr_ohbother_Config(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("ohbother.Config", p))
}

// Converters for non-pointer handles for type: ohbother.ContinuousPacketReceiver
func ptrFromHandle_ohbother_ContinuousPacketReceiver(h CGoHandle) *ohbother.ContinuousPacketReceiver {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "ohbother.ContinuousPacketReceiver")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ohbother.ContinuousPacketReceiver{})).(*ohbother.ContinuousPacketReceiver)
}
func handleFromPtr_ohbother_ContinuousPacketReceiver(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("ohbother.ContinuousPacketReceiver", p))
}

// Converters for non-pointer handles for type: ohbother.DebugOptions
func ptrFromHandle_ohbother_DebugOptions(h CGoHandle) *ohbother.DebugOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "ohbother.DebugOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ohbother.DebugOptions{})).(*ohbother.DebugOptions)
}
func handleFromPtr_ohbother_DebugOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("ohbother.DebugOptions", p))
}

// Converters for non-pointer handles for type: ohbother.DefaultLogger
func ptrFromHandle_ohbother_DefaultLogger(h CGoHandle) *ohbother.DefaultLogger {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "ohbother.DefaultLogger")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ohbother.DefaultLogger{})).(*ohbother.DefaultLogger)
}
func handleFromPtr_ohbother_DefaultLogger(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("ohbother.DefaultLogger", p))
}

// Converters for pointer handles for type: ohbother.Logger
func ptrFromHandle_ohbother_Logger(h CGoHandle) ohbother.Logger {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "ohbother.Logger")
	if p == nil {
		return nil
	}
	return p.(ohbother.Logger)
}
func handleFromPtr_ohbother_Logger(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("ohbother.Logger", p))
}

// Converters for non-pointer handles for type: ohbother.MultiStreamConfig
func ptrFromHandle_ohbother_MultiStreamConfig(h CGoHandle) *ohbother.MultiStreamConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "ohbother.MultiStreamConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ohbother.MultiStreamConfig{})).(*ohbother.MultiStreamConfig)
}
func handleFromPtr_ohbother_MultiStreamConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("ohbother.MultiStreamConfig", p))
}

// Converters for non-pointer handles for type: ohbother.MultiStreamSender
func ptrFromHandle_ohbother_MultiStreamSender(h CGoHandle) *ohbother.MultiStreamSender {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "ohbother.MultiStreamSender")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ohbother.MultiStreamSender{})).(*ohbother.MultiStreamSender)
}
func handleFromPtr_ohbother_MultiStreamSender(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("ohbother.MultiStreamSender", p))
}

// Converters for non-pointer handles for type: ohbother.PacketConfig
func ptrFromHandle_ohbother_PacketConfig(h CGoHandle) *ohbother.PacketConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "ohbother.PacketConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ohbother.PacketConfig{})).(*ohbother.PacketConfig)
}
func handleFromPtr_ohbother_PacketConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("ohbother.PacketConfig", p))
}

// Converters for non-pointer handles for type: ohbother.PacketReceiver
func ptrFromHandle_ohbother_PacketReceiver(h CGoHandle) *ohbother.PacketReceiver {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "ohbother.PacketReceiver")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ohbother.PacketReceiver{})).(*ohbother.PacketReceiver)
}
func handleFromPtr_ohbother_PacketReceiver(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("ohbother.PacketReceiver", p))
}

// Converters for non-pointer handles for type: ohbother.PacketSendResult
func ptrFromHandle_ohbother_PacketSendResult(h CGoHandle) *ohbother.PacketSendResult {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "ohbother.PacketSendResult")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ohbother.PacketSendResult{})).(*ohbother.PacketSendResult)
}
func handleFromPtr_ohbother_PacketSendResult(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("ohbother.PacketSendResult", p))
}

// Converters for non-pointer handles for type: ohbother.PacketSequenceSender
func ptrFromHandle_ohbother_PacketSequenceSender(h CGoHandle) *ohbother.PacketSequenceSender {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "ohbother.PacketSequenceSender")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ohbother.PacketSequenceSender{})).(*ohbother.PacketSequenceSender)
}
func handleFromPtr_ohbother_PacketSequenceSender(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("ohbother.PacketSequenceSender", p))
}

// Converters for non-pointer handles for type: ohbother.PcapConfig
func ptrFromHandle_ohbother_PcapConfig(h CGoHandle) *ohbother.PcapConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "ohbother.PcapConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(ohbother.PcapConfig{})).(*ohbother.PcapConfig)
}
func handleFromPtr_ohbother_PcapConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("ohbother.PcapConfig", p))
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

//export ohbother_Logger_Debug
func ohbother_Logger_Debug(_handle CGoHandle, format *C.char, args CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "ohbother.Logger")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(ohbother.Logger).Debug(C.GoString(format), deptrFromHandle_Slice_interface_(args)...)
	} else {
		vifc.(ohbother.Logger).Debug(C.GoString(format), deptrFromHandle_Slice_interface_(args)...)
	}
}

//export ohbother_Logger_Error
func ohbother_Logger_Error(_handle CGoHandle, format *C.char, args CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "ohbother.Logger")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(ohbother.Logger).Error(C.GoString(format), deptrFromHandle_Slice_interface_(args)...)
	} else {
		vifc.(ohbother.Logger).Error(C.GoString(format), deptrFromHandle_Slice_interface_(args)...)
	}
}

//export ohbother_Logger_Info
func ohbother_Logger_Info(_handle CGoHandle, format *C.char, args CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "ohbother.Logger")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(ohbother.Logger).Info(C.GoString(format), deptrFromHandle_Slice_interface_(args)...)
	} else {
		vifc.(ohbother.Logger).Info(C.GoString(format), deptrFromHandle_Slice_interface_(args)...)
	}
}

//export ohbother_Logger_Warn
func ohbother_Logger_Warn(_handle CGoHandle, format *C.char, args CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "ohbother.Logger")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(ohbother.Logger).Warn(C.GoString(format), deptrFromHandle_Slice_interface_(args)...)
	} else {
		vifc.(ohbother.Logger).Warn(C.GoString(format), deptrFromHandle_Slice_interface_(args)...)
	}
}

// ---- Structs ---

// --- wrapping struct: ohbother.MultiStreamConfig ---
//
//export ohbother_MultiStreamConfig_CTor
func ohbother_MultiStreamConfig_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_ohbother_MultiStreamConfig(&ohbother.MultiStreamConfig{}))
}

//export ohbother_MultiStreamConfig_PacketWorkers_Get
func ohbother_MultiStreamConfig_PacketWorkers_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_ohbother_MultiStreamConfig(handle)
	return C.longlong(op.PacketWorkers)
}

//export ohbother_MultiStreamConfig_PacketWorkers_Set
func ohbother_MultiStreamConfig_PacketWorkers_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_ohbother_MultiStreamConfig(handle)
	op.PacketWorkers = int(val)
}

//export ohbother_MultiStreamConfig_StreamCount_Get
func ohbother_MultiStreamConfig_StreamCount_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_ohbother_MultiStreamConfig(handle)
	return C.longlong(op.StreamCount)
}

//export ohbother_MultiStreamConfig_StreamCount_Set
func ohbother_MultiStreamConfig_StreamCount_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_ohbother_MultiStreamConfig(handle)
	op.StreamCount = int(val)
}

//export ohbother_MultiStreamConfig_ChannelBuffers_Get
func ohbother_MultiStreamConfig_ChannelBuffers_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_ohbother_MultiStreamConfig(handle)
	return C.longlong(op.ChannelBuffers)
}

//export ohbother_MultiStreamConfig_ChannelBuffers_Set
func ohbother_MultiStreamConfig_ChannelBuffers_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_ohbother_MultiStreamConfig(handle)
	op.ChannelBuffers = int(val)
}

//export ohbother_MultiStreamConfig_ReportInterval_Get
func ohbother_MultiStreamConfig_ReportInterval_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_ohbother_MultiStreamConfig(handle)
	return C.longlong(op.ReportInterval)
}

//export ohbother_MultiStreamConfig_ReportInterval_Set
func ohbother_MultiStreamConfig_ReportInterval_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_ohbother_MultiStreamConfig(handle)
	op.ReportInterval = int(val)
}

//export ohbother_MultiStreamConfig_EnableCPUPinning_Get
func ohbother_MultiStreamConfig_EnableCPUPinning_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_ohbother_MultiStreamConfig(handle)
	return boolGoToPy(op.EnableCPUPinning)
}

//export ohbother_MultiStreamConfig_EnableCPUPinning_Set
func ohbother_MultiStreamConfig_EnableCPUPinning_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_ohbother_MultiStreamConfig(handle)
	op.EnableCPUPinning = boolPyToGo(val)
}

//export ohbother_MultiStreamConfig_DisableOrdering_Get
func ohbother_MultiStreamConfig_DisableOrdering_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_ohbother_MultiStreamConfig(handle)
	return boolGoToPy(op.DisableOrdering)
}

//export ohbother_MultiStreamConfig_DisableOrdering_Set
func ohbother_MultiStreamConfig_DisableOrdering_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_ohbother_MultiStreamConfig(handle)
	op.DisableOrdering = boolPyToGo(val)
}

//export ohbother_MultiStreamConfig_TurnstileBurst_Get
func ohbother_MultiStreamConfig_TurnstileBurst_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_ohbother_MultiStreamConfig(handle)
	return C.longlong(op.TurnstileBurst)
}

//export ohbother_MultiStreamConfig_TurnstileBurst_Set
func ohbother_MultiStreamConfig_TurnstileBurst_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_ohbother_MultiStreamConfig(handle)
	op.TurnstileBurst = int(val)
}

//export ohbother_MultiStreamConfig_EnableMetrics_Get
func ohbother_MultiStreamConfig_EnableMetrics_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_ohbother_MultiStreamConfig(handle)
	return boolGoToPy(op.EnableMetrics)
}

//export ohbother_MultiStreamConfig_EnableMetrics_Set
func ohbother_MultiStreamConfig_EnableMetrics_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_ohbother_MultiStreamConfig(handle)
	op.EnableMetrics = boolPyToGo(val)
}

// --- wrapping struct: ohbother.MultiStreamSender ---
//
//export ohbother_MultiStreamSender_CTor
func ohbother_MultiStreamSender_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_ohbother_MultiStreamSender(&ohbother.MultiStreamSender{}))
}

//export ohbother_MultiStreamSender_Cfg_Get
func ohbother_MultiStreamSender_Cfg_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_ohbother_MultiStreamSender(handle)
	return handleFromPtr_Ptr_ohbother_Config(op.Cfg)
}

//export ohbother_MultiStreamSender_Cfg_Set
func ohbother_MultiStreamSender_Cfg_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_ohbother_MultiStreamSender(handle)
	op.Cfg = ptrFromHandle_Ptr_ohbother_Config(val)
}

//export ohbother_MultiStreamSender_StreamConfig_Get
func ohbother_MultiStreamSender_StreamConfig_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_ohbother_MultiStreamSender(handle)
	return handleFromPtr_Ptr_ohbother_MultiStreamConfig(op.StreamConfig)
}

//export ohbother_MultiStreamSender_StreamConfig_Set
func ohbother_MultiStreamSender_StreamConfig_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_ohbother_MultiStreamSender(handle)
	op.StreamConfig = ptrFromHandle_Ptr_ohbother_MultiStreamConfig(val)
}

//export ohbother_MultiStreamSender_RateLimit_Get
func ohbother_MultiStreamSender_RateLimit_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_ohbother_MultiStreamSender(handle)
	return C.longlong(op.RateLimit)
}

//export ohbother_MultiStreamSender_RateLimit_Set
func ohbother_MultiStreamSender_RateLimit_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_ohbother_MultiStreamSender(handle)
	op.RateLimit = int(val)
}

//export ohbother_MultiStreamSender_Payloads_Get
func ohbother_MultiStreamSender_Payloads_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_ohbother_MultiStreamSender(handle)
	return handleFromPtr_Slice_Slice_byte(&op.Payloads)
}

//export ohbother_MultiStreamSender_Payloads_Set
func ohbother_MultiStreamSender_Payloads_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_ohbother_MultiStreamSender(handle)
	op.Payloads = deptrFromHandle_Slice_Slice_byte(val)
}

//export ohbother_MultiStreamSender_SetStreamConfig
func ohbother_MultiStreamSender_SetStreamConfig(_handle CGoHandle, packetWorkers C.longlong, streamCount C.longlong, channelBuffers C.longlong, reportInterval C.longlong, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ohbother.MultiStreamSender")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(ohbother.MultiStreamSender{})).(*ohbother.MultiStreamSender).SetStreamConfig(int(packetWorkers), int(streamCount), int(channelBuffers), int(reportInterval))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(ohbother.MultiStreamSender{})).(*ohbother.MultiStreamSender).SetStreamConfig(int(packetWorkers), int(streamCount), int(channelBuffers), int(reportInterval))
	}
}

//export ohbother_MultiStreamSender_SetAdvancedConfig
func ohbother_MultiStreamSender_SetAdvancedConfig(_handle CGoHandle, enableCPUPinning C.char, disableOrdering C.char, turnstileBurst C.longlong, enableMetrics C.char, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ohbother.MultiStreamSender")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(ohbother.MultiStreamSender{})).(*ohbother.MultiStreamSender).SetAdvancedConfig(boolPyToGo(enableCPUPinning), boolPyToGo(disableOrdering), int(turnstileBurst), boolPyToGo(enableMetrics))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(ohbother.MultiStreamSender{})).(*ohbother.MultiStreamSender).SetAdvancedConfig(boolPyToGo(enableCPUPinning), boolPyToGo(disableOrdering), int(turnstileBurst), boolPyToGo(enableMetrics))
	}
}

//export ohbother_MultiStreamSender_AddPayload
func ohbother_MultiStreamSender_AddPayload(_handle CGoHandle, payload CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ohbother.MultiStreamSender")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(ohbother.MultiStreamSender{})).(*ohbother.MultiStreamSender).AddPayload(deptrFromHandle_Slice_byte(payload))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(ohbother.MultiStreamSender{})).(*ohbother.MultiStreamSender).AddPayload(deptrFromHandle_Slice_byte(payload))
	}
}

//export ohbother_MultiStreamSender_Send
func ohbother_MultiStreamSender_Send(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ohbother.MultiStreamSender")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(ohbother.MultiStreamSender{})).(*ohbother.MultiStreamSender).Send()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export ohbother_MultiStreamSender_GetMetrics
func ohbother_MultiStreamSender_GetMetrics(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ohbother.MultiStreamSender")
	if __err != nil {
		return handleFromPtr_Map_string_uint64(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(ohbother.MultiStreamSender{})).(*ohbother.MultiStreamSender).GetMetrics()

	return handleFromPtr_Map_string_uint64(&cret)
}

//export ohbother_MultiStreamSender_IsComplete
func ohbother_MultiStreamSender_IsComplete(_handle CGoHandle) C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ohbother.MultiStreamSender")
	if __err != nil {
		return boolGoToPy(false)
	}
	return boolGoToPy(gopyh.Embed(vifc, reflect.TypeOf(ohbother.MultiStreamSender{})).(*ohbother.MultiStreamSender).IsComplete())

}

//export ohbother_MultiStreamSender_GetNextResult
func ohbother_MultiStreamSender_GetNextResult(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ohbother.MultiStreamSender")
	if __err != nil {
		return handleFromPtr_Ptr_ohbother_PacketSendResult(nil)
	}
	return handleFromPtr_Ptr_ohbother_PacketSendResult(gopyh.Embed(vifc, reflect.TypeOf(ohbother.MultiStreamSender{})).(*ohbother.MultiStreamSender).GetNextResult())

}

//export ohbother_MultiStreamSender_Wait
func ohbother_MultiStreamSender_Wait(_handle CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ohbother.MultiStreamSender")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(ohbother.MultiStreamSender{})).(*ohbother.MultiStreamSender).Wait()
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(ohbother.MultiStreamSender{})).(*ohbother.MultiStreamSender).Wait()
	}
}

//export ohbother_MultiStreamSender_GetSentCount
func ohbother_MultiStreamSender_GetSentCount(_handle CGoHandle) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ohbother.MultiStreamSender")
	if __err != nil {
		return C.longlong(0)
	}
	return C.longlong(gopyh.Embed(vifc, reflect.TypeOf(ohbother.MultiStreamSender{})).(*ohbother.MultiStreamSender).GetSentCount())

}

//export ohbother_MultiStreamSender_GetErrorCount
func ohbother_MultiStreamSender_GetErrorCount(_handle CGoHandle) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ohbother.MultiStreamSender")
	if __err != nil {
		return C.longlong(0)
	}
	return C.longlong(gopyh.Embed(vifc, reflect.TypeOf(ohbother.MultiStreamSender{})).(*ohbother.MultiStreamSender).GetErrorCount())

}

//export ohbother_MultiStreamSender_GetStreamConfig
func ohbother_MultiStreamSender_GetStreamConfig(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ohbother.MultiStreamSender")
	if __err != nil {
		return handleFromPtr_Ptr_ohbother_MultiStreamConfig(nil)
	}
	return handleFromPtr_Ptr_ohbother_MultiStreamConfig(gopyh.Embed(vifc, reflect.TypeOf(ohbother.MultiStreamSender{})).(*ohbother.MultiStreamSender).GetStreamConfig())

}

//export ohbother_MultiStreamSender_IsOrderingEnabled
func ohbother_MultiStreamSender_IsOrderingEnabled(_handle CGoHandle) C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ohbother.MultiStreamSender")
	if __err != nil {
		return boolGoToPy(false)
	}
	return boolGoToPy(gopyh.Embed(vifc, reflect.TypeOf(ohbother.MultiStreamSender{})).(*ohbother.MultiStreamSender).IsOrderingEnabled())

}

//export ohbother_MultiStreamSender_IsCPUPinningEnabled
func ohbother_MultiStreamSender_IsCPUPinningEnabled(_handle CGoHandle) C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ohbother.MultiStreamSender")
	if __err != nil {
		return boolGoToPy(false)
	}
	return boolGoToPy(gopyh.Embed(vifc, reflect.TypeOf(ohbother.MultiStreamSender{})).(*ohbother.MultiStreamSender).IsCPUPinningEnabled())

}

//export ohbother_MultiStreamSender_GetTurnstileBurst
func ohbother_MultiStreamSender_GetTurnstileBurst(_handle CGoHandle) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ohbother.MultiStreamSender")
	if __err != nil {
		return C.longlong(0)
	}
	return C.longlong(gopyh.Embed(vifc, reflect.TypeOf(ohbother.MultiStreamSender{})).(*ohbother.MultiStreamSender).GetTurnstileBurst())

}

//export ohbother_MultiStreamSender_AreMetricsEnabled
func ohbother_MultiStreamSender_AreMetricsEnabled(_handle CGoHandle) C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ohbother.MultiStreamSender")
	if __err != nil {
		return boolGoToPy(false)
	}
	return boolGoToPy(gopyh.Embed(vifc, reflect.TypeOf(ohbother.MultiStreamSender{})).(*ohbother.MultiStreamSender).AreMetricsEnabled())

}

//export ohbother_MultiStreamSender_FastConvertPayloads
func ohbother_MultiStreamSender_FastConvertPayloads(_handle CGoHandle, payloads CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ohbother.MultiStreamSender")
	if __err != nil {
		return handleFromPtr_Slice_Slice_byte(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(ohbother.MultiStreamSender{})).(*ohbother.MultiStreamSender).FastConvertPayloads(deptrFromHandle_Slice_Slice_byte(payloads))

	return handleFromPtr_Slice_Slice_byte(&cret)
}

// --- wrapping struct: ohbother.PacketReceiver ---
//
//export ohbother_PacketReceiver_CTor
func ohbother_PacketReceiver_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_ohbother_PacketReceiver(&ohbother.PacketReceiver{}))
}

//export ohbother_PacketReceiver_Result
func ohbother_PacketReceiver_Result(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ohbother.PacketReceiver")
	if __err != nil {
		return handleFromPtr_Ptr_ohbother_AsyncResult(nil)
	}
	return handleFromPtr_Ptr_ohbother_AsyncResult(gopyh.Embed(vifc, reflect.TypeOf(ohbother.PacketReceiver{})).(*ohbother.PacketReceiver).Result())

}

//export ohbother_PacketReceiver_ResultNative
func ohbother_PacketReceiver_ResultNative(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ohbother.PacketReceiver")
	if __err != nil {
		return handleFromPtr_Slice_Slice_byte(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(ohbother.PacketReceiver{})).(*ohbother.PacketReceiver).ResultNative()

	return handleFromPtr_Slice_Slice_byte(&cret)
}

// --- wrapping struct: ohbother.PacketSendResult ---
//
//export ohbother_PacketSendResult_CTor
func ohbother_PacketSendResult_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_ohbother_PacketSendResult(&ohbother.PacketSendResult{}))
}

//export ohbother_PacketSendResult_Index_Get
func ohbother_PacketSendResult_Index_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_ohbother_PacketSendResult(handle)
	return C.longlong(op.Index)
}

//export ohbother_PacketSendResult_Index_Set
func ohbother_PacketSendResult_Index_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_ohbother_PacketSendResult(handle)
	op.Index = int(val)
}

//export ohbother_PacketSendResult_TotalCount_Get
func ohbother_PacketSendResult_TotalCount_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_ohbother_PacketSendResult(handle)
	return C.longlong(op.TotalCount)
}

//export ohbother_PacketSendResult_TotalCount_Set
func ohbother_PacketSendResult_TotalCount_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_ohbother_PacketSendResult(handle)
	op.TotalCount = int(val)
}

//export ohbother_PacketSendResult_Elapsed_Get
func ohbother_PacketSendResult_Elapsed_Get(handle CGoHandle) C.double {
	op := ptrFromHandle_ohbother_PacketSendResult(handle)
	return C.double(op.Elapsed)
}

//export ohbother_PacketSendResult_Elapsed_Set
func ohbother_PacketSendResult_Elapsed_Set(handle CGoHandle, val C.double) {
	op := ptrFromHandle_ohbother_PacketSendResult(handle)
	op.Elapsed = float64(val)
}

//export ohbother_PacketSendResult_GetError
func ohbother_PacketSendResult_GetError(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ohbother.PacketSendResult")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(gopyh.Embed(vifc, reflect.TypeOf(ohbother.PacketSendResult{})).(*ohbother.PacketSendResult).GetError())

}

// --- wrapping struct: ohbother.Config ---
//
//export ohbother_Config_CTor
func ohbother_Config_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_ohbother_Config(&ohbother.Config{}))
}

//export ohbother_Config_Pcap_Get
func ohbother_Config_Pcap_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_ohbother_Config(handle)
	return handleFromPtr_Ptr_ohbother_PcapConfig(op.Pcap)
}

//export ohbother_Config_Pcap_Set
func ohbother_Config_Pcap_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_ohbother_Config(handle)
	op.Pcap = ptrFromHandle_Ptr_ohbother_PcapConfig(val)
}

//export ohbother_Config_Packet_Get
func ohbother_Config_Packet_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_ohbother_Config(handle)
	return handleFromPtr_Ptr_ohbother_PacketConfig(op.Packet)
}

//export ohbother_Config_Packet_Set
func ohbother_Config_Packet_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_ohbother_Config(handle)
	op.Packet = ptrFromHandle_Ptr_ohbother_PacketConfig(val)
}

//export ohbother_Config_Debug_Get
func ohbother_Config_Debug_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_ohbother_Config(handle)
	return handleFromPtr_ohbother_DebugOptions(&op.Debug)
}

//export ohbother_Config_Debug_Set
func ohbother_Config_Debug_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_ohbother_Config(handle)
	op.Debug = *ptrFromHandle_ohbother_DebugOptions(val)
}

//export ohbother_Config_EnableDebug
func ohbother_Config_EnableDebug(_handle CGoHandle, level C.longlong, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ohbother.Config")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(ohbother.Config{})).(*ohbother.Config).EnableDebug(int(level))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(ohbother.Config{})).(*ohbother.Config).EnableDebug(int(level))
	}
}

//export ohbother_Config_DisableDebug
func ohbother_Config_DisableDebug(_handle CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ohbother.Config")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(ohbother.Config{})).(*ohbother.Config).DisableDebug()
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(ohbother.Config{})).(*ohbother.Config).DisableDebug()
	}
}

//export ohbother_Config_SetLogger
func ohbother_Config_SetLogger(_handle CGoHandle, logger CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ohbother.Config")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(ohbother.Config{})).(*ohbother.Config).SetLogger(ptrFromHandle_ohbother_Logger(logger))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(ohbother.Config{})).(*ohbother.Config).SetLogger(ptrFromHandle_ohbother_Logger(logger))
	}
}

// --- wrapping struct: ohbother.DebugOptions ---
//
//export ohbother_DebugOptions_CTor
func ohbother_DebugOptions_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_ohbother_DebugOptions(&ohbother.DebugOptions{}))
}

//export ohbother_DebugOptions_Enabled_Get
func ohbother_DebugOptions_Enabled_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_ohbother_DebugOptions(handle)
	return boolGoToPy(op.Enabled)
}

//export ohbother_DebugOptions_Enabled_Set
func ohbother_DebugOptions_Enabled_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_ohbother_DebugOptions(handle)
	op.Enabled = boolPyToGo(val)
}

//export ohbother_DebugOptions_Level_Get
func ohbother_DebugOptions_Level_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_ohbother_DebugOptions(handle)
	return C.longlong(op.Level)
}

//export ohbother_DebugOptions_Level_Set
func ohbother_DebugOptions_Level_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_ohbother_DebugOptions(handle)
	op.Level = int(val)
}

//export ohbother_DebugOptions_Logger_Get
func ohbother_DebugOptions_Logger_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_ohbother_DebugOptions(handle)
	return handleFromPtr_ohbother_Logger(op.Logger)
}

//export ohbother_DebugOptions_Logger_Set
func ohbother_DebugOptions_Logger_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_ohbother_DebugOptions(handle)
	op.Logger = ptrFromHandle_ohbother_Logger(val)
}

// --- wrapping struct: ohbother.PacketConfig ---
//
//export ohbother_PacketConfig_CTor
func ohbother_PacketConfig_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_ohbother_PacketConfig(&ohbother.PacketConfig{}))
}

//export ohbother_PacketConfig_SrcMAC_Get
func ohbother_PacketConfig_SrcMAC_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_ohbother_PacketConfig(handle)
	return handleFromPtr_net_HardwareAddr(&op.SrcMAC)
}

//export ohbother_PacketConfig_SrcMAC_Set
func ohbother_PacketConfig_SrcMAC_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_ohbother_PacketConfig(handle)
	op.SrcMAC = deptrFromHandle_net_HardwareAddr(val)
}

//export ohbother_PacketConfig_DstMAC_Get
func ohbother_PacketConfig_DstMAC_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_ohbother_PacketConfig(handle)
	return handleFromPtr_net_HardwareAddr(&op.DstMAC)
}

//export ohbother_PacketConfig_DstMAC_Set
func ohbother_PacketConfig_DstMAC_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_ohbother_PacketConfig(handle)
	op.DstMAC = deptrFromHandle_net_HardwareAddr(val)
}

//export ohbother_PacketConfig_SrcIP_Get
func ohbother_PacketConfig_SrcIP_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_ohbother_PacketConfig(handle)
	return C.CString(op.SrcIP)
}

//export ohbother_PacketConfig_SrcIP_Set
func ohbother_PacketConfig_SrcIP_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_ohbother_PacketConfig(handle)
	op.SrcIP = C.GoString(val)
}

//export ohbother_PacketConfig_DstIP_Get
func ohbother_PacketConfig_DstIP_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_ohbother_PacketConfig(handle)
	return C.CString(op.DstIP)
}

//export ohbother_PacketConfig_DstIP_Set
func ohbother_PacketConfig_DstIP_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_ohbother_PacketConfig(handle)
	op.DstIP = C.GoString(val)
}

//export ohbother_PacketConfig_SrcPort_Get
func ohbother_PacketConfig_SrcPort_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_ohbother_PacketConfig(handle)
	return C.longlong(op.SrcPort)
}

//export ohbother_PacketConfig_SrcPort_Set
func ohbother_PacketConfig_SrcPort_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_ohbother_PacketConfig(handle)
	op.SrcPort = int(val)
}

//export ohbother_PacketConfig_DstPort_Get
func ohbother_PacketConfig_DstPort_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_ohbother_PacketConfig(handle)
	return C.longlong(op.DstPort)
}

//export ohbother_PacketConfig_DstPort_Set
func ohbother_PacketConfig_DstPort_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_ohbother_PacketConfig(handle)
	op.DstPort = int(val)
}

//export ohbother_PacketConfig_BPF_Get
func ohbother_PacketConfig_BPF_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_ohbother_PacketConfig(handle)
	return C.CString(op.BPF)
}

//export ohbother_PacketConfig_BPF_Set
func ohbother_PacketConfig_BPF_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_ohbother_PacketConfig(handle)
	op.BPF = C.GoString(val)
}

// --- wrapping struct: ohbother.PacketSequenceSender ---
//
//export ohbother_PacketSequenceSender_CTor
func ohbother_PacketSequenceSender_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_ohbother_PacketSequenceSender(&ohbother.PacketSequenceSender{}))
}

//export ohbother_PacketSequenceSender_Cfg_Get
func ohbother_PacketSequenceSender_Cfg_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_ohbother_PacketSequenceSender(handle)
	return handleFromPtr_Ptr_ohbother_Config(op.Cfg)
}

//export ohbother_PacketSequenceSender_Cfg_Set
func ohbother_PacketSequenceSender_Cfg_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_ohbother_PacketSequenceSender(handle)
	op.Cfg = ptrFromHandle_Ptr_ohbother_Config(val)
}

//export ohbother_PacketSequenceSender_RateLimit_Get
func ohbother_PacketSequenceSender_RateLimit_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_ohbother_PacketSequenceSender(handle)
	return C.longlong(op.RateLimit)
}

//export ohbother_PacketSequenceSender_RateLimit_Set
func ohbother_PacketSequenceSender_RateLimit_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_ohbother_PacketSequenceSender(handle)
	op.RateLimit = int(val)
}

//export ohbother_PacketSequenceSender_Payloads_Get
func ohbother_PacketSequenceSender_Payloads_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_ohbother_PacketSequenceSender(handle)
	return handleFromPtr_Slice_Slice_byte(&op.Payloads)
}

//export ohbother_PacketSequenceSender_Payloads_Set
func ohbother_PacketSequenceSender_Payloads_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_ohbother_PacketSequenceSender(handle)
	op.Payloads = deptrFromHandle_Slice_Slice_byte(val)
}

//export ohbother_PacketSequenceSender_AddPayload
func ohbother_PacketSequenceSender_AddPayload(_handle CGoHandle, payload CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ohbother.PacketSequenceSender")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(ohbother.PacketSequenceSender{})).(*ohbother.PacketSequenceSender).AddPayload(deptrFromHandle_Slice_byte(payload))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(ohbother.PacketSequenceSender{})).(*ohbother.PacketSequenceSender).AddPayload(deptrFromHandle_Slice_byte(payload))
	}
}

//export ohbother_PacketSequenceSender_Send
func ohbother_PacketSequenceSender_Send(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ohbother.PacketSequenceSender")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(ohbother.PacketSequenceSender{})).(*ohbother.PacketSequenceSender).Send()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export ohbother_PacketSequenceSender_GetNextResult
func ohbother_PacketSequenceSender_GetNextResult(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ohbother.PacketSequenceSender")
	if __err != nil {
		return handleFromPtr_Ptr_ohbother_PacketSendResult(nil)
	}
	return handleFromPtr_Ptr_ohbother_PacketSendResult(gopyh.Embed(vifc, reflect.TypeOf(ohbother.PacketSequenceSender{})).(*ohbother.PacketSequenceSender).GetNextResult())

}

//export ohbother_PacketSequenceSender_IsComplete
func ohbother_PacketSequenceSender_IsComplete(_handle CGoHandle) C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ohbother.PacketSequenceSender")
	if __err != nil {
		return boolGoToPy(false)
	}
	return boolGoToPy(gopyh.Embed(vifc, reflect.TypeOf(ohbother.PacketSequenceSender{})).(*ohbother.PacketSequenceSender).IsComplete())

}

// --- wrapping struct: ohbother.PcapConfig ---
//
//export ohbother_PcapConfig_CTor
func ohbother_PcapConfig_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_ohbother_PcapConfig(&ohbother.PcapConfig{}))
}

//export ohbother_PcapConfig_Iface_Get
func ohbother_PcapConfig_Iface_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_ohbother_PcapConfig(handle)
	return C.CString(op.Iface)
}

//export ohbother_PcapConfig_Iface_Set
func ohbother_PcapConfig_Iface_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_ohbother_PcapConfig(handle)
	op.Iface = C.GoString(val)
}

//export ohbother_PcapConfig_SnapLen_Get
func ohbother_PcapConfig_SnapLen_Get(handle CGoHandle) C.long {
	op := ptrFromHandle_ohbother_PcapConfig(handle)
	return C.long(op.SnapLen)
}

//export ohbother_PcapConfig_SnapLen_Set
func ohbother_PcapConfig_SnapLen_Set(handle CGoHandle, val C.long) {
	op := ptrFromHandle_ohbother_PcapConfig(handle)
	op.SnapLen = int32(val)
}

//export ohbother_PcapConfig_Promisc_Get
func ohbother_PcapConfig_Promisc_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_ohbother_PcapConfig(handle)
	return boolGoToPy(op.Promisc)
}

//export ohbother_PcapConfig_Promisc_Set
func ohbother_PcapConfig_Promisc_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_ohbother_PcapConfig(handle)
	op.Promisc = boolPyToGo(val)
}

//export ohbother_PcapConfig_Timeout_Get
func ohbother_PcapConfig_Timeout_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_ohbother_PcapConfig(handle)
	return C.longlong(int64(op.Timeout))
}

//export ohbother_PcapConfig_Timeout_Set
func ohbother_PcapConfig_Timeout_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_ohbother_PcapConfig(handle)
	op.Timeout = time.Duration(int64(val))
}

//export ohbother_PcapConfig_BufferSize_Get
func ohbother_PcapConfig_BufferSize_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_ohbother_PcapConfig(handle)
	return C.longlong(op.BufferSize)
}

//export ohbother_PcapConfig_BufferSize_Set
func ohbother_PcapConfig_BufferSize_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_ohbother_PcapConfig(handle)
	op.BufferSize = int(val)
}

//export ohbother_PcapConfig_ImmediateMode_Get
func ohbother_PcapConfig_ImmediateMode_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_ohbother_PcapConfig(handle)
	return boolGoToPy(op.ImmediateMode)
}

//export ohbother_PcapConfig_ImmediateMode_Set
func ohbother_PcapConfig_ImmediateMode_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_ohbother_PcapConfig(handle)
	op.ImmediateMode = boolPyToGo(val)
}

// --- wrapping struct: ohbother.AsyncResult ---
//
//export ohbother_AsyncResult_CTor
func ohbother_AsyncResult_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_ohbother_AsyncResult(&ohbother.AsyncResult{}))
}

//export ohbother_AsyncResult_Packets_Get
func ohbother_AsyncResult_Packets_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_ohbother_AsyncResult(handle)
	return handleFromPtr_Slice_Slice_byte(&op.Packets)
}

//export ohbother_AsyncResult_Packets_Set
func ohbother_AsyncResult_Packets_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_ohbother_AsyncResult(handle)
	op.Packets = deptrFromHandle_Slice_Slice_byte(val)
}

//export ohbother_AsyncResult_GetPackets
func ohbother_AsyncResult_GetPackets(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ohbother.AsyncResult")
	if __err != nil {
		return handleFromPtr_Slice_Slice_byte(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(ohbother.AsyncResult{})).(*ohbother.AsyncResult).GetPackets()

	return handleFromPtr_Slice_Slice_byte(&cret)
}

//export ohbother_AsyncResult_GetErr
func ohbother_AsyncResult_GetErr(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ohbother.AsyncResult")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(ohbother.AsyncResult{})).(*ohbother.AsyncResult).GetErr()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: ohbother.BytePacket ---
//
//export ohbother_BytePacket_CTor
func ohbother_BytePacket_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_ohbother_BytePacket(&ohbother.BytePacket{}))
}

//export ohbother_BytePacket_Data_Get
func ohbother_BytePacket_Data_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_ohbother_BytePacket(handle)
	return handleFromPtr_Slice_byte(&op.Data)
}

//export ohbother_BytePacket_Data_Set
func ohbother_BytePacket_Data_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_ohbother_BytePacket(handle)
	op.Data = deptrFromHandle_Slice_byte(val)
}

//export ohbother_BytePacket_GetData
func ohbother_BytePacket_GetData(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ohbother.BytePacket")
	if __err != nil {
		return handleFromPtr_Slice_byte(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(ohbother.BytePacket{})).(*ohbother.BytePacket).GetData()

	return handleFromPtr_Slice_byte(&cret)
}

// --- wrapping struct: ohbother.ContinuousPacketReceiver ---
//
//export ohbother_ContinuousPacketReceiver_CTor
func ohbother_ContinuousPacketReceiver_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_ohbother_ContinuousPacketReceiver(&ohbother.ContinuousPacketReceiver{}))
}

//export ohbother_ContinuousPacketReceiver_GetNextPacket
func ohbother_ContinuousPacketReceiver_GetNextPacket(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ohbother.ContinuousPacketReceiver")
	if __err != nil {
		return handleFromPtr_Slice_byte(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(ohbother.ContinuousPacketReceiver{})).(*ohbother.ContinuousPacketReceiver).GetNextPacket()

	return handleFromPtr_Slice_byte(&cret)
}

//export ohbother_ContinuousPacketReceiver_Close
func ohbother_ContinuousPacketReceiver_Close(_handle CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ohbother.ContinuousPacketReceiver")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(ohbother.ContinuousPacketReceiver{})).(*ohbother.ContinuousPacketReceiver).Close()
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(ohbother.ContinuousPacketReceiver{})).(*ohbother.ContinuousPacketReceiver).Close()
	}
}

// --- wrapping struct: ohbother.DefaultLogger ---
//
//export ohbother_DefaultLogger_CTor
func ohbother_DefaultLogger_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_ohbother_DefaultLogger(&ohbother.DefaultLogger{}))
}

//export ohbother_DefaultLogger_Debug
func ohbother_DefaultLogger_Debug(_handle CGoHandle, format *C.char, args CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ohbother.DefaultLogger")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(ohbother.DefaultLogger{})).(*ohbother.DefaultLogger).Debug(C.GoString(format), deptrFromHandle_Slice_interface_(args)...)
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(ohbother.DefaultLogger{})).(*ohbother.DefaultLogger).Debug(C.GoString(format), deptrFromHandle_Slice_interface_(args)...)
	}
}

//export ohbother_DefaultLogger_Info
func ohbother_DefaultLogger_Info(_handle CGoHandle, format *C.char, args CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ohbother.DefaultLogger")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(ohbother.DefaultLogger{})).(*ohbother.DefaultLogger).Info(C.GoString(format), deptrFromHandle_Slice_interface_(args)...)
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(ohbother.DefaultLogger{})).(*ohbother.DefaultLogger).Info(C.GoString(format), deptrFromHandle_Slice_interface_(args)...)
	}
}

//export ohbother_DefaultLogger_Warn
func ohbother_DefaultLogger_Warn(_handle CGoHandle, format *C.char, args CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ohbother.DefaultLogger")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(ohbother.DefaultLogger{})).(*ohbother.DefaultLogger).Warn(C.GoString(format), deptrFromHandle_Slice_interface_(args)...)
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(ohbother.DefaultLogger{})).(*ohbother.DefaultLogger).Warn(C.GoString(format), deptrFromHandle_Slice_interface_(args)...)
	}
}

//export ohbother_DefaultLogger_Error
func ohbother_DefaultLogger_Error(_handle CGoHandle, format *C.char, args CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*ohbother.DefaultLogger")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(ohbother.DefaultLogger{})).(*ohbother.DefaultLogger).Error(C.GoString(format), deptrFromHandle_Slice_interface_(args)...)
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(ohbother.DefaultLogger{})).(*ohbother.DefaultLogger).Error(C.GoString(format), deptrFromHandle_Slice_interface_(args)...)
	}
}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export ohbother_NewMultiStreamSender
func ohbother_NewMultiStreamSender(cfg CGoHandle, rateLimit C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_ohbother_MultiStreamSender(ohbother.NewMultiStreamSender(ptrFromHandle_Ptr_ohbother_Config(cfg), int(rateLimit)))

}

//export ohbother_BenchmarkReceiveAsync
func ohbother_BenchmarkReceiveAsync(cfg CGoHandle, duration C.double) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_ohbother_PacketReceiver(ohbother.BenchmarkReceiveAsync(ptrFromHandle_Ptr_ohbother_Config(cfg), float64(duration)))

}

//export ohbother_PacketReceiverByCount
func ohbother_PacketReceiverByCount(cfg CGoHandle, count C.longlong, timeout C.double) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_ohbother_PacketReceiver(ohbother.PacketReceiverByCount(ptrFromHandle_Ptr_ohbother_Config(cfg), int(count), float64(timeout)))

}

//export ohbother_PacketReceiverByTime
func ohbother_PacketReceiverByTime(cfg CGoHandle, duration C.double) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_ohbother_PacketReceiver(ohbother.PacketReceiverByTime(ptrFromHandle_Ptr_ohbother_Config(cfg), float64(duration)))

}

//export ohbother_NewDefaultConfig
func ohbother_NewDefaultConfig(iface *C.char, srcMAC *C.char, dstMAC *C.char, srcIP *C.char, dstIP *C.char, srcPort C.longlong, dstPort C.longlong, bpf *C.char, SnapLen C.longlong, Promisc C.char, BufferSize C.longlong, ImmediateMode C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := ohbother.NewDefaultConfig(C.GoString(iface), C.GoString(srcMAC), C.GoString(dstMAC), C.GoString(srcIP), C.GoString(dstIP), int(srcPort), int(dstPort), C.GoString(bpf), int(SnapLen), boolPyToGo(Promisc), int(BufferSize), boolPyToGo(ImmediateMode))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_ohbother_Config(nil)
	}
	return handleFromPtr_Ptr_ohbother_Config(cret)
}

//export ohbother_NewPacketSequenceSender
func ohbother_NewPacketSequenceSender(cfg CGoHandle, rateLimit C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_ohbother_PacketSequenceSender(ohbother.NewPacketSequenceSender(ptrFromHandle_Ptr_ohbother_Config(cfg), int(rateLimit)))

}

//export ohbother_NewBytePacket
func ohbother_NewBytePacket(data CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_ohbother_BytePacket(ohbother.NewBytePacket(deptrFromHandle_Slice_byte(data)))

}

//export ohbother_NewReceiver
func ohbother_NewReceiver(cfg CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_ohbother_ContinuousPacketReceiver(ohbother.NewReceiver(ptrFromHandle_Ptr_ohbother_Config(cfg)))

}

//export ohbother_NewDefaultLogger
func ohbother_NewDefaultLogger(cfg CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_ohbother_DefaultLogger(ohbother.NewDefaultLogger(ptrFromHandle_Ptr_ohbother_Config(cfg)))

}

// ---- Functions ---

//export ohbother_PayloadNative
func ohbother_PayloadNative(pyPayload *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := ohbother.PayloadNative(C.GoString(pyPayload))

	return handleFromPtr_Slice_Slice_byte(&cret)
}

//export ohbother_ReceivePacketsByTimeSync
func ohbother_ReceivePacketsByTimeSync(cfg CGoHandle, duration C.double) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := ohbother.ReceivePacketsByTimeSync(ptrFromHandle_Ptr_ohbother_Config(cfg), float64(duration))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_Slice_byte(nil)
	}
	return handleFromPtr_Slice_Slice_byte(&cret)
}

//export ohbother_SendPackets
func ohbother_SendPackets(cfg CGoHandle, rawPayloads *C.char, rateLimit C.longlong) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	var __err error
	__err = ohbother.SendPackets(ptrFromHandle_Ptr_ohbother_Config(cfg), C.GoString(rawPayloads), int(rateLimit))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export ohbother_SendByteArrays
func ohbother_SendByteArrays(cfg CGoHandle, bytePayloads CGoHandle, rateLimit C.longlong) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	var __err error
	__err = ohbother.SendByteArrays(ptrFromHandle_Ptr_ohbother_Config(cfg), deptrFromHandle_Slice_Slice_byte(bytePayloads), int(rateLimit))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export ohbother_SendPacket
func ohbother_SendPacket(cfg CGoHandle, payload CGoHandle, rateLimit C.longlong) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	var __err error
	__err = ohbother.SendPacket(ptrFromHandle_Ptr_ohbother_Config(cfg), deptrFromHandle_Slice_byte(payload), int(rateLimit))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export ohbother_LogError
func ohbother_LogError(format *C.char, args CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	if boolPyToGo(goRun) {
		go ohbother.LogError(C.GoString(format), deptrFromHandle_Slice_interface_(args)...)
	} else {
		ohbother.LogError(C.GoString(format), deptrFromHandle_Slice_interface_(args)...)
	}
}

//export ohbother_LogInfo
func ohbother_LogInfo(format *C.char, args CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	if boolPyToGo(goRun) {
		go ohbother.LogInfo(C.GoString(format), deptrFromHandle_Slice_interface_(args)...)
	} else {
		ohbother.LogInfo(C.GoString(format), deptrFromHandle_Slice_interface_(args)...)
	}
}

//export ohbother_LogWarn
func ohbother_LogWarn(format *C.char, args CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	if boolPyToGo(goRun) {
		go ohbother.LogWarn(C.GoString(format), deptrFromHandle_Slice_interface_(args)...)
	} else {
		ohbother.LogWarn(C.GoString(format), deptrFromHandle_Slice_interface_(args)...)
	}
}

//export ohbother_NewSliceByteFromBytes
func ohbother_NewSliceByteFromBytes(data CGoHandle) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return C.longlong(ohbother.NewSliceByteFromBytes(deptrFromHandle_Slice_byte(data)))

}

//export ohbother_DeleteSliceBytes
func ohbother_DeleteSliceBytes(handle C.longlong, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	if boolPyToGo(goRun) {
		go ohbother.DeleteSliceBytes(int64(handle))
	} else {
		ohbother.DeleteSliceBytes(int64(handle))
	}
}

//export ohbother_ReceivePacketsByCountSync
func ohbother_ReceivePacketsByCountSync(cfg CGoHandle, count C.longlong, timeout C.double) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := ohbother.ReceivePacketsByCountSync(ptrFromHandle_Ptr_ohbother_Config(cfg), int(count), float64(timeout))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_Slice_byte(nil)
	}
	return handleFromPtr_Slice_Slice_byte(&cret)
}

//export ohbother_BatchConvertPythonBytesToSlices
func ohbother_BatchConvertPythonBytesToSlices(rawBytes CGoHandle, numWorkers C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := ohbother.BatchConvertPythonBytesToSlices(deptrFromHandle_Slice_Slice_byte(rawBytes), int(numWorkers))

	return handleFromPtr_Slice_int64(&cret)
}

//export ohbother_BenchmarkSend
func ohbother_BenchmarkSend(cfg CGoHandle, packetCount C.longlong, payloadSize C.longlong, rateLimit C.longlong) C.double {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := ohbother.BenchmarkSend(ptrFromHandle_Ptr_ohbother_Config(cfg), int(packetCount), int(payloadSize), int(rateLimit))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.double(0)
	}
	return C.double(cret)
}

//export ohbother_LogDebug
func ohbother_LogDebug(format *C.char, args CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	if boolPyToGo(goRun) {
		go ohbother.LogDebug(C.GoString(format), deptrFromHandle_Slice_interface_(args)...)
	} else {
		ohbother.LogDebug(C.GoString(format), deptrFromHandle_Slice_interface_(args)...)
	}
}
